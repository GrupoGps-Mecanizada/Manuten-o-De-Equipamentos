<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>GrupoGPS Mecanizada - Sistema de Dupla Checagem de Manutenção</title>
  <!-- Favicon -->
  <link rel="icon" href="data:,">

  <!-- Chart.js para gráficos -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>

  <!-- Estilo CSS -->
  <style>
    :root {
      --primary-color: #0056b3;
      --secondary-color: #2e4b85;
      --accent-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
      --text-color: #333;
      --text-light: #777;
      --bg-color: #f8f9fa;
      --card-bg: #ffffff;
      --border-color: #ddd;
      --shadow-color: rgba(0,0,0,0.1);
    }

    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.5;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      padding: 10px;
    }

    .header {
      background-color: var(--primary-color);
      color: white;
      padding: 15px;
      border-radius: 8px 8px 0 0;
      margin-bottom: 15px;
      box-shadow: 0 2px 8px var(--shadow-color);
    }

    .header h1 {
      font-size: 20px;
      margin: 0;
    }

    .header p {
      font-size: 14px;
      margin: 5px 0 0;
      opacity: 0.9;
    }

    .company-branding {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .company-logo {
      font-size: 18px;
      font-weight: bold;
      color: white;
      text-decoration: none;
    }

    .notification-badge {
      background-color: var(--accent-color);
      color: white;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: bold;
    }

    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .date-filter {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .date-filter select {
      padding: 8px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: white;
    }

    .summary-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }

    .card {
      background-color: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      padding: 20px;
      flex: 1 1 calc(25% - 15px);
      min-width: 200px;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px var(--shadow-color);
    }

    .card-title {
      font-size: 14px;
      color: var(--text-light);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }

    .card-title i {
      margin-right: 8px;
      font-size: 16px;
    }

    .card-value {
      font-size: 24px;
      font-weight: bold;
      color: var(--primary-color);
    }

    .card-footer {
      margin-top: 10px;
      font-size: 12px;
      color: var(--text-light);
      display: flex;
      align-items: center;
    }

    .card-trend {
      margin-left: 8px;
      padding: 3px 6px;
      border-radius: 12px;
      font-weight: bold;
    }

    .trend-up {
      background-color: rgba(40, 167, 69, 0.1);
      color: var(--accent-color);
    }

    .trend-down {
      background-color: rgba(220, 53, 69, 0.1);
      color: var(--danger-color);
    }

    .section {
      background-color: var(--card-bg);
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow-color);
      padding: 20px;
      margin-bottom: 20px;
    }

    .section-title {
      font-size: 18px;
      color: var(--text-color);
      margin: 0 0 15px 0;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .section-actions {
      display: flex;
      gap: 10px;
    }

    .btn-icon {
      background: none;
      border: none;
      color: var(--text-light);
      cursor: pointer;
      padding: 5px;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .btn-icon:hover {
      background-color: rgba(0,0,0,0.05);
      color: var(--primary-color);
    }

    .chart-container {
      position: relative;
      height: 300px;
      margin-bottom: 20px;
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-bottom: 20px;
    }

    .table-responsive {
      overflow-x: auto;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      background-color: white;
    }

    th {
      background-color: rgba(0,0,0,0.03);
      text-align: left;
      padding: 12px 15px;
      border-bottom: 2px solid var(--border-color);
      color: var(--text-color);
      font-weight: 600;
    }

    td {
      padding: 12px 15px;
      border-bottom: 1px solid var(--border-color);
      vertical-align: middle;
    }

    tr:hover {
      background-color: rgba(0,0,0,0.01);
    }

    tr:last-child td {
      border-bottom: none;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    .status-pending {
      background-color: rgba(255, 193, 7, 0.2);
      color: #d49c00;
    }

    .status-verification {
      background-color: rgba(13, 110, 253, 0.2);
      color: #0d6efd;
    }

    .status-completed {
      background-color: rgba(40, 167, 69, 0.2);
      color: var(--accent-color);
    }
    /* Adicionado para Reprovado/Danger */
    .status-danger {
      background-color: rgba(220, 53, 69, 0.1);
      color: var(--danger-color);
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 20px;
      overflow-x: auto;
      scrollbar-width: thin;
    }

    .tab {
      padding: 12px 20px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 500;
      white-space: nowrap;
      border-bottom: 2px solid transparent;
    }

    .tab.active {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
    }

    .tab:hover:not(.active) {
      border-bottom: 2px solid rgba(0,0,0,0.1);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .search-container {
      margin-bottom: 20px;
    }

    .search-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-size: 15px;
      transition: all 0.2s;
      background-color: white;
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 86, 179, 0.1);
    }

    .filter-container {
      display: flex;
      margin-bottom: 20px;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: 5px;
      gap: 10px;
    }

    .filter-item {
      background-color: white;
      border: 1px solid var(--border-color);
      border-radius: 20px;
      padding: 8px 15px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .filter-item.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    .filter-item:hover:not(.active) {
      background-color: rgba(0,0,0,0.03);
    }

    .badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }

    .badge-success {
      background-color: var(--accent-color);
      color: white;
    }

    .badge-warning {
      background-color: var(--warning-color);
      color: #212529;
    }

    .badge-danger {
      background-color: var(--danger-color);
      color: white;
    }

    .badge-info {
      background-color: #17a2b8;
      color: white;
    }

    .progress-container {
      width: 100%;
      background-color: var(--bg-color);
      border-radius: 4px;
      height: 8px;
      overflow: hidden;
      margin-top: 5px;
    }

    .progress-bar {
      height: 100%;
      background-color: var(--accent-color);
      border-radius: 4px;
      transition: width 0.5s;
    }

    .btn {
      display: inline-block;
      background-color: var(--primary-color);
      color: white;
      padding: 10px 15px;
      border-radius: 4px;
      text-decoration: none;
      border: none;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      text-align: center;
      transition: all 0.2s;
    }

    .btn:hover {
      background-color: var(--secondary-color);
    }

    .btn-success {
      background-color: var(--accent-color);
    }

    .btn-success:hover {
      background-color: #218838;
    }

    .btn-danger {
      background-color: var(--danger-color);
    }

    .btn-danger:hover {
      background-color: #bd2130;
    }

    .btn-sm {
      padding: 5px 10px;
      font-size: 13px;
    }

    .btn-lg {
      padding: 12px 20px;
      font-size: 16px;
    }

    .btn-block {
      display: block;
      width: 100%;
    }

    .btn-outline {
      background-color: transparent;
      border: 1px solid var(--primary-color);
      color: var(--primary-color);
    }

    .btn-outline:hover {
      background-color: var(--primary-color);
      color: white;
    }

    .btn-outline-success {
      border-color: var(--accent-color);
      color: var(--accent-color);
    }

    .btn-outline-success:hover {
      background-color: var(--accent-color);
      color: white;
    }

    .btn-new {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background-color: var(--accent-color);
      color: white;
      text-align: center;
      line-height: 60px;
      font-size: 24px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      z-index: 100;
      transition: all 0.3s ease;
    }

    .btn-new:hover {
      transform: scale(1.1);
      background-color: #218838;
    }

    .btn-action-group {
      display: flex;
      gap: 10px;
    }

    /* Estilos para o formulário de manutenção */
    .form-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .form-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 700px;
      max-height: 90vh;
      overflow-y: auto;
      background-color: white;
      border-radius: 8px;
      padding: 25px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }

    .form-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 15px;
    }

    .form-title {
      font-size: 20px;
      font-weight: 600;
      margin: 0;
    }

    .form-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-light);
      transition: color 0.2s;
    }

    .form-close:hover {
      color: var(--danger-color);
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      font-size: 15px;
    }

    .form-control {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 15px;
      transition: all 0.2s;
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(0, 86, 179, 0.1);
    }

    .form-row {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
    }

    .form-col {
      flex: 1;
    }

    .form-check {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }

    .form-check input[type="radio"],
    .form-check input[type="checkbox"] {
      margin-right: 8px;
    }

    .form-check label {
      margin: 0;
      font-weight: normal;
    }

    .form-steps {
      display: flex;
      justify-content: space-between;
      margin-bottom: 30px;
      position: relative;
    }

    .form-steps::before {
      content: '';
      position: absolute;
      top: 14px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: var(--border-color);
      z-index: 1;
    }

    .form-step {
      position: relative;
      z-index: 2;
      text-align: center;
      flex: 1;
    }

    .step-number {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: white;
      border: 2px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 8px;
      font-weight: bold;
      color: var(--text-light);
      position: relative;
      z-index: 2;
    }

    .form-step.active .step-number {
      background-color: var(--primary-color);
      border-color: var(--primary-color);
      color: white;
    }

    .form-step.completed .step-number {
      background-color: var(--accent-color);
      border-color: var(--accent-color);
      color: white;
    }

    .step-label {
      font-size: 13px;
      color: var(--text-light);
    }

    .form-step.active .step-label {
      color: var(--primary-color);
      font-weight: 500;
    }

    .form-step.completed .step-label {
      color: var(--accent-color);
      font-weight: 500;
    }

    .form-navigation {
      display: flex;
      justify-content: space-between;
      margin-top: 30px;
      border-top: 1px solid var(--border-color);
      padding-top: 20px;
    }

    .form-required {
      color: var(--danger-color);
      margin-left: 2px;
    }

    .camera-container {
      width: 100%;
      position: relative;
      margin-bottom: 15px;
    }

    .camera-preview {
      width: 100%;
      height: 300px;
      background-color: #eee;
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .camera-preview video,
    .camera-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .camera-button {
      flex: 1;
      min-width: 120px;
    }

    .image-gallery {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }

    .image-item {
      width: 100px;
      height: 100px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      position: relative;
      cursor: pointer; /* Add cursor for viewing */
    }

    .image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .image-remove {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 20px;
      height: 20px;
      background-color: rgba(0,0,0,0.5);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px; /* Reduced size slightly */
      cursor: pointer;
      line-height: 20px; /* Ensure symbol is centered */
      text-align: center;
    }

    .notification-popup {
      position: fixed;
      top: 20px;
      right: 20px;
      min-width: 280px;
      max-width: 350px;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      z-index: 1050;
      animation: slideIn 0.3s ease-out forwards;
      font-weight: 500;
      display: flex;
      align-items: flex-start;
    }

    .notification-icon {
      margin-right: 12px;
      font-size: 20px;
    }

    .notification-content {
      flex: 1;
    }

    .notification-title {
      font-weight: 600;
      margin-bottom: 5px;
      font-size: 16px;
    }

    .notification-popup.success {
      background-color: #d4edda;
      border-left: 4px solid var(--accent-color);
      color: #155724;
    }

    .notification-popup.error {
      background-color: #f8d7da;
      border-left: 4px solid var(--danger-color);
      color: #721c24;
    }

    .notification-popup.info {
      background-color: #d1ecf1;
      border-left: 4px solid #17a2b8;
      color: #0c5460;
    }

    /* Adicionado tipo warning */
    .notification-popup.warning {
      background-color: #fff3cd;
      border-left: 4px solid var(--warning-color);
      color: #856404;
    }


    .notification-popup .close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 16px;
      cursor: pointer;
      color: inherit;
      opacity: 0.7;
    }

    .notification-popup .close-btn:hover {
      opacity: 1;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }

    /* Estilos para detalhes da manutenção */
    .maintenance-detail {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .detail-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
    }

    .detail-header-left {
      flex: 1;
      min-width: 280px;
    }

    .detail-header-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }

    .detail-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .detail-subtitle {
      font-size: 14px;
      color: var(--text-light);
    }

    .detail-section {
      margin-bottom: 15px;
    }

    .detail-section-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px dashed var(--border-color);
    }

    .detail-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 15px;
    }

    .detail-field {
      margin-bottom: 10px;
    }

    .detail-label {
      font-size: 12px;
      color: var(--text-light);
      margin-bottom: 3px;
    }

    .detail-value {
      font-size: 15px;
      font-weight: 500;
    }

    .detail-image-gallery {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }

    .detail-image-item {
      width: 150px;
      height: 150px;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid var(--border-color);
      transition: transform 0.2s;
      cursor: pointer;
    }

    .detail-image-item:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .detail-image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .timeline {
      position: relative;
      margin-left: 20px;
      padding-left: 20px;
      border-left: 2px solid var(--border-color);
    }

    .timeline-item {
      position: relative;
      margin-bottom: 20px;
      padding-bottom: 10px;
    }

    .timeline-item:last-child {
      margin-bottom: 0;
    }

    .timeline-dot {
      position: absolute;
      left: -31px;
      top: 0;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: var(--primary-color);
      border: 3px solid white;
    }

    .timeline-dot.completed {
      background-color: var(--accent-color);
    }

    .timeline-content {
      background-color: #f9f9f9;
      padding: 15px;
      border-radius: 4px;
      margin-top: -5px;
    }

    .timeline-title {
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }

    .timeline-date {
      font-size: 12px;
      color: var(--text-light);
    }

    .timeline-description {
      font-size: 14px;
      margin-top: 5px;
    }

    #imageModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.9);
      z-index: 1100;
      padding: 20px;
      align-items: center; /* Added for centering */
      justify-content: center; /* Added for centering */
    }

    #modalImage {
      display: block;
      max-width: 90%;
      max-height: 90%;
      margin: auto; /* Simplified margin */
      object-fit: contain;
    }

    #closeModal {
      position: absolute;
      top: 15px;
      right: 25px;
      color: white;
      font-size: 30px;
      font-weight: bold;
      cursor: pointer;
    }

    .footer {
      text-align: center;
      padding: 20px 0;
      color: var(--text-light);
      font-size: 13px;
      margin-top: 30px;
      border-top: 1px solid var(--border-color);
    }

    .developer-credit {
      font-size: 12px;
      color: var(--text-light);
      margin-top: 5px;
    }

    /* Responsividade */
    @media (max-width: 768px) {
      .grid-container {
        grid-template-columns: 1fr;
      }

      .summary-cards {
        flex-direction: column;
      }

      .card {
        flex: 1 1 100%;
        min-width: 100%;
      }

      .form-row {
        flex-direction: column;
        gap: 10px;
      }

      .form-steps {
        overflow-x: auto;
        padding-bottom: 10px;
      }

      .step-label {
        font-size: 11px;
      }

      .btn-new {
        width: 50px;
        height: 50px;
        line-height: 50px;
        font-size: 20px;
        bottom: 20px;
        right: 20px;
      }

      .section {
        padding: 15px;
      }

      .form-container {
        width: 95%;
        padding: 15px;
      }

      .detail-image-item {
        width: 120px;
        height: 120px;
      }
    }

    @media (min-width: 769px) and (max-width: 1024px) {
      .grid-container {
        grid-template-columns: 1fr 1fr;
      }

      .card {
        flex: 1 1 calc(50% - 15px);
      }
    }

    @media (min-width: 1025px) {
      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .chart-container {
        height: 350px;
      }
    }
  </style>
  <!-- PASSO 1: Adicione as bibliotecas do Google na seção <head> do HTML -->
  <!-- Adicione estas linhas antes do fechamento da tag </head> -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://accounts.google.com/gsi/client"></script>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="company-branding">
        <a href="#" class="company-logo">GrupoGPS - Mecanizada</a>
        <span class="notification-badge">Manutenção</span>
      </div>
      <h1>Sistema de Dupla Checagem de Manutenção</h1>
      <p>Registro, verificação e controle de manutenções</p>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="dashboard">Dashboard</div>
      <div class="tab" data-tab="maintenance">Manutenções</div>
      <div class="tab" data-tab="verification">Verificações</div>
      <div class="tab" data-tab="reports">Relatórios</div>
    </div>

    <!-- Dashboard Tab -->
    <div class="tab-content active" id="tab-dashboard">
      <div class="dashboard-header">
        <h2>Visão Geral</h2>
        <div class="date-filter">
          <label for="period-filter">Período:</label>
          <select id="period-filter">
            <option value="all">Todos</option>
            <option value="current-month" selected>Mês Atual</option>
            <option value="last-month">Mês Anterior</option>
            <option value="last-3-months">Últimos 3 Meses</option>
          </select>
        </div>
      </div>

      <!-- Resumo em cards -->
      <div class="summary-cards">
        <div class="card">
          <div class="card-title">
            <i class="icon">🔧</i>
            Total de Manutenções
          </div>
          <div class="card-value" id="total-maintenance">0</div>
          <div class="card-footer">
            <span>Período selecionado</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">
            <i class="icon">⌛</i>
            Aguardando Verificação
          </div>
          <div class="card-value" id="pending-verification">0</div>
          <div class="card-footer">
            <span>Precisa de atenção</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">
            <i class="icon">✅</i>
            Verificações Concluídas
          </div>
          <div class="card-value" id="completed-verifications">0</div>
          <div class="card-footer">
            <span>Período atual</span>
            <span class="card-trend trend-up" id="verification-trend">+0.0%</span>
          </div>
        </div>

        <div class="card">
          <div class="card-title">
            <i class="icon">⚠️</i>
            Manutenções Críticas
          </div>
          <div class="card-value" id="critical-maintenance">0</div>
          <div class="card-footer">
            <span>Atenção necessária</span>
          </div>
        </div>
      </div>

      <!-- Gráficos -->
      <div class="grid-container">
        <div class="section">
          <h3 class="section-title">
            Manutenções por Tipo
            <div class="section-actions">
              <button class="btn-icon" id="refresh-type-chart" title="Atualizar">↻</button>
            </div>
          </h3>
          <div class="chart-container">
            <canvas id="maintenance-type-chart"></canvas>
          </div>
        </div>

        <div class="section">
          <h3 class="section-title">
            Status das Manutenções
            <div class="section-actions">
              <button class="btn-icon" id="refresh-status-chart" title="Atualizar">↻</button>
            </div>
          </h3>
          <div class="chart-container">
            <canvas id="maintenance-status-chart"></canvas>
          </div>
        </div>
      </div>

      <!-- Equipamentos com mais manutenções -->
      <div class="section">
        <h3 class="section-title">
          Equipamentos com Mais Manutenções
          <div class="section-actions">
            <button class="btn-icon" id="refresh-equipment-ranking" title="Atualizar">↻</button>
          </div>
        </h3>
        <div class="table-responsive">
          <table id="equipment-ranking-table">
            <thead>
              <tr>
                <th>Equipamento</th>
                <th>Tipo</th>
                <th>Total Manutenções</th>
                <th>Última Manutenção</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody id="equipment-ranking-tbody">
              <!-- Dados serão preenchidos via JavaScript -->
            </tbody>
          </table>
        </div>
      </div>

      <!-- Manutenções Recentes -->
      <div class="section">
        <h3 class="section-title">Manutenções Recentes</h3>
        <div class="table-responsive">
          <table id="recent-maintenance-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Equipamento</th>
                <th>Tipo</th>
                <th>Data Registro</th>
                <th>Técnico</th>
                <th>Status</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="recent-maintenance-tbody">
              <!-- Dados serão preenchidos via JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Manutenções Tab -->
    <div class="tab-content" id="tab-maintenance">
      <div class="section">
        <div class="search-container">
          <input type="text" class="search-input" id="maintenance-search" placeholder="Buscar por ID, equipamento, técnico...">
        </div>

        <div class="filter-container">
          <div class="filter-item active" data-filter="all">Todos</div>
          <div class="filter-item" data-filter="pending">Aguardando Verificação</div>
          <div class="filter-item" data-filter="verified">Verificados</div>
          <div class="filter-item" data-filter="completed">Concluídos</div>
        </div>

        <h3 class="section-title">
          Lista de Manutenções
          <div class="section-actions">
            <button class="btn-icon" id="refresh-maintenance-list" title="Atualizar">↻</button>
          </div>
        </h3>

        <div class="table-responsive">
          <table id="maintenance-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Equipamento</th>
                <th>Tipo</th>
                <th>Data Registro</th>
                <th>Técnico</th>
                <th>Status</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="maintenance-tbody">
              <!-- Dados serão preenchidos via JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Verificações Tab -->
    <div class="tab-content" id="tab-verification">
      <div class="section">
        <div class="search-container">
          <input type="text" class="search-input" id="verification-search" placeholder="Buscar por ID, equipamento, técnico...">
        </div>

        <div class="filter-container">
          <div class="filter-item active" data-filter="all">Todos</div>
          <div class="filter-item" data-filter="pending">Aguardando Verificação</div>
          <div class="filter-item" data-filter="verified">Verificados Hoje</div>
          <div class="filter-item" data-filter="completed">Concluídos</div>
        </div>

        <h3 class="section-title">
          Verificações Pendentes
          <div class="section-actions">
            <button class="btn-icon" id="refresh-verification-list" title="Atualizar">↻</button>
          </div>
        </h3>

        <div class="table-responsive">
          <table id="verification-table">
            <thead>
              <tr>
                <th>ID</th>
                <th>Equipamento</th>
                <th>Tipo</th>
                <th>Data Manutenção</th>
                <th>Técnico</th>
                <th>Status</th>
                <th>Ações</th>
              </tr>
            </thead>
            <tbody id="verification-tbody">
              <!-- Dados serão preenchidos via JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Relatórios Tab -->
    <div class="tab-content" id="tab-reports">
      <div class="section">
        <h3 class="section-title">Relatórios por Período</h3>
        <div class="form-row">
          <div class="form-col">
            <div class="form-group">
              <label for="report-start-date">Data Inicial</label>
              <input type="date" class="form-control" id="report-start-date">
            </div>
          </div>
          <div class="form-col">
            <div class="form-group">
              <label for="report-end-date">Data Final</label>
              <input type="date" class="form-control" id="report-end-date">
            </div>
          </div>
          <div class="form-col" style="display: flex; align-items: flex-end;">
            <button class="btn" id="generate-report">Gerar Relatório</button>
          </div>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Análise por Tipo de Problema</h3>
        <div class="chart-container">
          <canvas id="problem-type-chart"></canvas>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Tempo Médio de Resolução</h3>
        <div class="chart-container">
          <canvas id="resolution-time-chart"></canvas>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Exportar Dados</h3>
        <div class="btn-action-group">
          <button class="btn" id="export-excel">Exportar para Excel</button>
          <button class="btn" id="export-pdf">Exportar para PDF</button>
          <button class="btn" id="print-report">Imprimir Relatório</button>
        </div>
      </div>
    </div>

    <!-- Formulário de Nova Manutenção -->
    <div class="form-overlay" id="maintenance-form-overlay">
      <div class="form-container">
        <div class="form-header">
          <h2 class="form-title">Registrar Nova Manutenção</h2>
          <button class="form-close" id="close-maintenance-form">&times;</button>
        </div>

        <div class="form-steps">
          <div class="form-step active" data-step="1">
            <div class="step-number">1</div>
            <div class="step-label">Informações</div>
          </div>
          <div class="form-step" data-step="2">
            <div class="step-number">2</div>
            <div class="step-label">Problema</div>
          </div>
          <div class="form-step" data-step="3">
            <div class="step-number">3</div>
            <div class="step-label">Fotos</div>
          </div>
        </div>

        <form id="maintenance-form">
          <!-- Etapa 1: Informações Básicas -->
          <div class="form-step-content" id="step-1-content">
            <div class="form-row">
              <div class="form-col">
                <div class="form-group">
                  <label for="equipment-id">ID do Equipamento <span class="form-required">*</span></label>
                  <input type="text" class="form-control" id="equipment-id" name="equipment-id" required>
                </div>
              </div>
              <div class="form-col">
                <div class="form-group">
                  <label for="equipment-type">Tipo de Equipamento <span class="form-required">*</span></label>
                  <select class="form-control" id="equipment-type" name="equipment-type" required>
                    <option value="">Selecione o tipo</option>
                    <option value="Caminhão">Caminhão</option>
                    <option value="Trator">Trator</option>
                    <option value="Escavadeira">Escavadeira</option>
                    <option value="Retroescavadeira">Retroescavadeira</option>
                    <option value="Carregadeira">Carregadeira</option>
                    <option value="Outro">Outro</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="form-row">
              <div class="form-col">
                <div class="form-group">
                  <label for="technician-name">Nome do Técnico <span class="form-required">*</span></label>
                  <input type="text" class="form-control" id="technician-name" name="technician-name" required>
                </div>
              </div>
              <div class="form-col">
                <div class="form-group">
                  <label for="maintenance-date">Data da Manutenção <span class="form-required">*</span></label>
                  <input type="date" class="form-control" id="maintenance-date" name="maintenance-date" required>
                </div>
              </div>
            </div>

            <div class="form-group">
              <label for="location">Local da Manutenção <span class="form-required">*</span></label>
              <input type="text" class="form-control" id="location" name="location" required>
            </div>

            <div class="form-group">
              <label for="maintenance-type">Tipo de Manutenção <span class="form-required">*</span></label>
              <select class="form-control" id="maintenance-type" name="maintenance-type" required>
                <option value="">Selecione o tipo</option>
                <option value="Preventiva">Preventiva</option>
                <option value="Corretiva">Corretiva</option>
                <option value="Emergencial">Emergencial</option>
              </select>
            </div>

            <div class="form-group">
              <div class="form-check">
                <input type="checkbox" id="is-critical" name="is-critical">
                <label for="is-critical">Manutenção Crítica (requer atenção imediata)</label>
              </div>
            </div>

            <div class="form-navigation">
              <button type="button" class="btn" id="cancel-maintenance">Cancelar</button>
              <button type="button" class="btn btn-success" id="next-to-step-2">Próximo</button>
            </div>
          </div>

          <!-- Etapa 2: Problema e Solução -->
          <div class="form-step-content" id="step-2-content" style="display: none;">
            <div class="form-group">
              <label for="problem-category">Categoria do Problema <span class="form-required">*</span></label>
              <select class="form-control" id="problem-category" name="problem-category" required>
                <option value="">Selecione a categoria</option>
                <option value="Motor">Motor</option>
                <option value="Transmissão">Transmissão</option>
                <option value="Sistema Hidráulico">Sistema Hidráulico</option>
                <option value="Sistema Elétrico">Sistema Elétrico</option>
                <option value="Freios">Freios</option>
                <option value="Suspensão">Suspensão</option>
                <option value="Outro">Outro</option>
              </select>
            </div>

            <div class="form-group">
              <label for="problem-description">Descrição do Problema <span class="form-required">*</span></label>
              <textarea class="form-control" id="problem-description" name="problem-description" rows="3" required></textarea>
            </div>

            <div class="form-group">
              <label for="solution-description">Descrição da Solução Aplicada <span class="form-required">*</span></label>
              <textarea class="form-control" id="solution-description" name="solution-description" rows="3" required></textarea>
            </div>

            <div class="form-group">
              <label for="parts-replaced">Peças Substituídas</label>
              <textarea class="form-control" id="parts-replaced" name="parts-replaced" rows="2"></textarea>
            </div>

            <div class="form-group">
              <label for="additional-notes">Observações Adicionais</label>
              <textarea class="form-control" id="additional-notes" name="additional-notes" rows="2"></textarea>
            </div>

            <div class="form-navigation">
              <button type="button" class="btn" id="back-to-step-1">Voltar</button>
              <button type="button" class="btn btn-success" id="next-to-step-3">Próximo</button>
            </div>
          </div>

          <!-- Etapa 3: Fotos e Evidências -->
          <div class="form-step-content" id="step-3-content" style="display: none;">
            <div class="form-group">
              <label>Fotos do Problema e Solução <span class="form-required">*</span></label>

              <div class="camera-container">
                <div class="camera-preview" id="camera-preview">
                  <video id="camera-stream" autoplay playsinline style="display:none;"></video>
                  <img id="captured-image" style="display:none;">
                  <div id="camera-placeholder" style="display:flex; height:100%; align-items:center; justify-content:center; background:#eee;">
                    <span>Clique em "Abrir Câmera" para capturar imagens</span>
                  </div>
                </div>

                <div class="camera-buttons">
                  <button type="button" class="btn camera-button" id="open-camera">Abrir Câmera</button>
                  <button type="button" class="btn camera-button" id="take-photo" disabled>Tirar Foto</button>
                  <button type="button" class="btn camera-button" id="upload-photo">Carregar Foto</button>
                  <input type="file" id="photo-upload" accept="image/*" style="display:none;">
                </div>
              </div>

              <div class="image-gallery" id="image-gallery">
                <!-- Imagens capturadas serão exibidas aqui -->
              </div>

              <div id="photo-warning" class="form-required" style="display:none; margin-top:5px;">
                É necessário adicionar pelo menos uma foto
              </div>
            </div>

            <div class="form-navigation">
              <button type="button" class="btn" id="back-to-step-2">Voltar</button>
              <button type="submit" class="btn btn-success" id="submit-maintenance">Finalizar Registro</button>
            </div>
          </div>
        </form>
      </div>
    </div>

    <!-- Formulário de Verificação de Manutenção -->
    <div class="form-overlay" id="verification-form-overlay">
      <div class="form-container">
        <div class="form-header">
          <h2 class="form-title">Verificação de Manutenção</h2>
          <button class="form-close" id="close-verification-form">&times;</button>
        </div>

        <form id="verification-form">
          <div class="form-group">
            <label for="verification-id">ID da Manutenção</label>
            <input type="text" class="form-control" id="verification-id" name="verification-id" readonly>
          </div>

          <div class="form-row">
            <div class="form-col">
              <div class="form-group">
                <label for="verification-equipment">Equipamento</label>
                <input type="text" class="form-control" id="verification-equipment" readonly>
              </div>
            </div>
            <div class="form-col">
              <div class="form-group">
                <label for="verification-type">Tipo de Manutenção</label>
                <input type="text" class="form-control" id="verification-type" readonly>
              </div>
            </div>
          </div>

          <div class="form-group">
            <label for="verifier-name">Nome do Verificador <span class="form-required">*</span></label>
            <input type="text" class="form-control" id="verifier-name" name="verifier-name" required>
          </div>

          <div class="form-group">
            <label>Resultado da Verificação <span class="form-required">*</span></label>
            <div class="form-check">
              <input type="radio" id="verification-approved" name="verification-result" value="Aprovado" required>
              <label for="verification-approved">Aprovado - Manutenção Correta</label>
            </div>
            <div class="form-check">
              <input type="radio" id="verification-adjustments" name="verification-result" value="Ajustes" required>
              <label for="verification-adjustments">Necessita Ajustes Menores</label>
            </div>
            <div class="form-check">
              <input type="radio" id="verification-rejected" name="verification-result" value="Reprovado" required>
              <label for="verification-rejected">Reprovado - Precisa de Nova Manutenção</label>
            </div>
          </div>

          <div class="form-group">
            <label for="verification-comments">Comentários da Verificação <span class="form-required">*</span></label>
            <textarea class="form-control" id="verification-comments" name="verification-comments" rows="3" required></textarea>
          </div>

          <div class="form-group">
            <label>Fotos da Verificação</label>

            <div class="camera-container">
              <div class="camera-preview" id="verification-camera-preview">
                <video id="verification-camera-stream" autoplay playsinline style="display:none;"></video>
                <img id="verification-captured-image" style="display:none;">
                <div id="verification-camera-placeholder" style="display:flex; height:100%; align-items:center; justify-content:center; background:#eee;">
                  <span>Clique em "Abrir Câmera" para capturar imagens</span>
                </div>
              </div>

              <div class="camera-buttons">
                <button type="button" class="btn camera-button" id="verification-open-camera">Abrir Câmera</button>
                <button type="button" class="btn camera-button" id="verification-take-photo" disabled>Tirar Foto</button>
                <button type="button" class="btn camera-button" id="verification-upload-photo">Carregar Foto</button>
                <input type="file" id="verification-photo-upload" accept="image/*" style="display:none;">
              </div>
            </div>

            <div class="image-gallery" id="verification-image-gallery">
              <!-- Imagens capturadas serão exibidas aqui -->
            </div>
          </div>

          <div class="form-navigation">
            <button type="button" class="btn" id="cancel-verification">Cancelar</button>
            <button type="submit" class="btn btn-success" id="submit-verification">Finalizar Verificação</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Detalhes da Manutenção -->
    <div class="form-overlay" id="detail-overlay">
      <div class="form-container">
        <div class="form-header">
          <h2 class="form-title">Detalhes da Manutenção</h2>
          <button class="form-close" id="close-detail">&times;</button>
        </div>

        <div class="maintenance-detail" id="maintenance-detail-content">
          <!-- Conteúdo será preenchido via JavaScript -->
        </div>

        <div class="form-navigation">
          <button class="btn" id="close-detail-btn">Fechar</button>
          <button class="btn btn-success" id="verify-maintenance-btn">Verificar Manutenção</button>
        </div>
      </div>
    </div>

    <!-- Modal para visualizar imagens -->
    <div id="imageModal">
      <span id="closeModal">&times;</span>
      <img id="modalImage">
    </div>

    <!-- Botão de Nova Manutenção -->
    <div class="btn-new" id="new-maintenance">+</div>

    <div class="footer">
      <p>Sistema de Dupla Checagem de Manutenção © 2025 | Última atualização: <span id="last-update">Carregando...</span></p>
      <p class="developer-credit">Desenvolvido por Warlison Abreu</p>
    </div>
  </div>

  <script>
    // Configuração da URL da API (URL do seu Google Script Web App publicado)
    const API_URL = 'https://script.google.com/macros/s/AKfycbyM4zw2zDzw_ybAyGFCHdsyjwAXsw-K3x2S1ca0NsTk0eB9s8E0XM9XNlTbiNrb5RadfQ/exec'; // SUBSTITUA PELO SEU ID

    // Variáveis globais
    let dashboardData = null;
    let maintenanceList = [];
    let capturedImages = [];
    let verificationImages = [];
    let currentTab = 'dashboard';
    let currentMaintenanceFilter = 'all';
    let currentVerificationFilter = 'all';
    let searchTerm = '';
    let charts = {};
    let cameraStream = null;
    let verificationCameraStream = null;
    let selectedMaintenanceId = null;
    let script = null; // Variável global para o elemento script JSONP

    // PASSO 2: Adicione as variáveis globais no JavaScript
    // Adicionar junto com outras variáveis globais
    let tokenClient = null;
    let accessToken = null;
    let gisInited = false;
    let gapiInited = false;

    // Document ready
    document.addEventListener('DOMContentLoaded', function() {
      // Inicializar o sistema
      setupEventListeners();
      loadDashboardData();

      // PASSO 5: Adicione a chamada de inicialização no DOMContentLoaded
      initGoogleAPI();

      // Define a data de hoje como padrão nos campos de data
      const today = new Date();
      document.getElementById('maintenance-date').valueAsDate = today;
      document.getElementById('report-start-date').valueAsDate = new Date(today.getFullYear(), today.getMonth(), 1);
      document.getElementById('report-end-date').valueAsDate = today;

      document.getElementById('last-update').textContent = formatDate(today, true);
    });

    // PASSO 3: Adicione a função de inicialização da API do Google
    // Função para inicializar a API do Google
    function initGoogleAPI() {
      console.log("Iniciando API do Google...");

      gapi.load('client', async () => {
        try {
          await gapi.client.init({
            // ATENÇÃO: Removi apiKey pois não é necessário para OAuth 2.0 com Drive v3 aqui
            // apiKey: 'SEU_API_KEY', // <-- Removido/Comentado se não for usado para Discovery puro sem Auth
            discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
          });
          console.log("GAPI client inicializado com sucesso");
          gapiInited = true;
          maybeEnableButtons();
        } catch (err) {
          console.error("Erro ao inicializar GAPI client:", err);
          // Informar o usuário pode ser útil aqui
          showNotification("Erro ao conectar com a API do Google Drive.", "error");
        }
      });

      // --- INÍCIO DA MODIFICAÇÃO 3 ---
      // Configurar cliente OAuth2
      try {
          tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: '987788711566-n9428umkv1noqtt09ib6scg4mqvjfo99.apps.googleusercontent.com',
            scope: 'https://www.googleapis.com/auth/drive.file',
            callback: (resp) => {
              if (resp.error !== undefined) {
                console.error("Erro na autenticação/obtenção de token:", resp);
                // Possivelmente desabilitar funcionalidades ou mostrar erro persistente
                accessToken = null; // Garante que não usemos um token antigo ou inválido
                showNotification("Falha na autenticação com o Google Drive. Funcionalidades de upload podem não funcionar.", "error");

                // Verificar tipos específicos de erro
                if (resp.error === 'popup_closed_by_user') {
                    showNotification("Janela de permissão do Google fechada. Tente a ação novamente.", "info");
                } else if (resp.error === 'access_denied') {
                     showNotification("Acesso ao Google Drive negado. Permissão é necessária para salvar fotos.", "warning");
                }
                return;
              }
              console.log("Token de acesso obtido/atualizado com sucesso.");
              accessToken = resp.access_token;
            },
            error_callback: (err) => { // Adicionado callback de erro para capturar problemas na inicialização
              console.error("Erro na inicialização do cliente de token Google:", err);
              showNotification("Erro crítico ao configurar autenticação Google.", "error");
              gisInited = false; // Marca como não inicializado para nova tentativa futura
            },
            // Adicionado parâmetros adicionais para melhorar compatibilidade
            prompt: '', // Vazio inicialmente para tentar autenticação silenciosa
            hint: '', // Adicionar email do usuário se disponível tornaria o processo mais suave
            state: 'auth_flow', // Identificador para o fluxo de autenticação
          });
          console.log("Google Sign-In (GIS) Token Client inicializado.");
          gisInited = true;
          maybeEnableButtons();
      } catch (gisError){
           console.error("Erro fatal ao inicializar Google Sign-In (GIS):", gisError);
           showNotification("Erro grave ao inicializar a autenticação Google. Upload de fotos indisponível.", "error");
           gisInited = false;
           // Tentativa de recuperação
           setTimeout(() => {
               showNotification("Tentando reinicializar conexão com Google...", "info");
               initGoogleAPI(); // Tenta inicializar novamente após um tempo
           }, 5000);
      }
      // --- FIM DA MODIFICAÇÃO 3 ---
    }

    function maybeEnableButtons() {
      // Esta função é chamada após GAPI e GIS inicializarem.
      // Pode ser usada para habilitar botões que dependem dessas APIs,
      // embora a lógica atual de `uploadFileToDrive` peça o token sob demanda.
      if (gapiInited && gisInited) {
        console.log("APIs do Google (GAPI Client e GIS Token Client) prontas para uso.");
        // Exemplo: Habilitar um botão de "Login com Google" se fosse necessário
        // ou apenas logar que está pronto.
      } else {
         console.log(`Status APIs Google: GAPI Client=${gapiInited}, GIS Token Client=${gisInited}`);
      }
    }

    // PASSO 4: Adicione as funções de suporte para o upload

    // Função melhorada para converter base64 para Blob (INÍCIO DA SUBSTITUIÇÃO - SEÇÃO 3.1)
    function base64ToBlob(base64Data) {
      return new Promise((resolve, reject) => {
        try {
          // Verificar entrada
          if (!base64Data || typeof base64Data !== 'string') {
            throw new Error('Dados base64 inválidos (string esperada)');
          }

          // Tratar tanto string base64 pura quanto data URI
          let contentType = 'image/jpeg'; // Tipo padrão
          let base64 = base64Data;

          // Verificar se é uma data URI
          const dataUriMatch = base64Data.match(/^data:([A-Za-z-+\/]+);base64,(.+)$/);
          if (dataUriMatch) {
            contentType = dataUriMatch[1] || contentType;
            base64 = dataUriMatch[2];
          } else if (base64Data.startsWith('/9j/') || base64Data.startsWith('iVBORw0K')) {
            // Provavelmente JPEG ou PNG sem prefixo
            console.log("Base64 sem prefixo detectado, assumindo " + contentType);
          } else if (!base64Data.match(/^[A-Za-z0-9+/=]+$/)) {
            throw new Error('Formato inválido - não é base64 válido');
          }

          // Decodificar base64
          const byteCharacters = atob(base64.trim());
          const byteArrays = [];

          // Criar chunks para processar arquivos grandes
          for (let offset = 0; offset < byteCharacters.length; offset += 512) {
            const slice = byteCharacters.slice(offset, offset + 512);
            const byteNumbers = new Array(slice.length);

            for (let i = 0; i < slice.length; i++) {
              byteNumbers[i] = slice.charCodeAt(i);
            }

            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
          }

          // Criar e retornar o blob
          const blob = new Blob(byteArrays, { type: contentType });
          resolve(blob);
        } catch (error) {
          console.error("Erro ao converter base64 para Blob:", error);
          reject(new Error(`Erro na conversão para Blob: ${error.message}`));
        }
      });
    }
    // (FIM DA SUBSTITUIÇÃO - SEÇÃO 3.1)

    // --- INÍCIO DA MODIFICAÇÃO 1 (Função antiga uploadFileToDrive substituída pela lógica dentro de uploadImageToDrive) ---
    // A função uploadFileToDrive abaixo será ADICIONADA junto com uploadAllImagesToDrive.
    // A lógica de upload dentro da função 'uploadFileToDrive' antiga foi incorporada na nova 'uploadImageToDrive'.

    // --- Funções auxiliares para gerenciar o botão de autenticação explícito ---
    // (A função antiga `uploadFileToDrive` foi removida ou substituída na prática pela nova `uploadImageToDrive` abaixo)
    // --- INÍCIO DA MODIFICAÇÃO 2 (Mantida) ---
    function showGoogleAuthButton(clickHandler) {
        // Remover botão existente se houver
        removeGoogleAuthButton();

        // Criar o container para o botão
        const container = document.createElement('div');
        container.id = 'google-auth-button-container';
        container.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 3000;
            text-align: center;
        `;

        // Criar o botão
        const button = document.createElement('button');
        button.id = 'google-auth-button';
        button.textContent = 'Autorizar Google Drive';
        button.style.cssText = `
            background-color: #4285F4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 10px auto;
        `;
        button.onclick = (e) => {
            e.preventDefault();
            clickHandler();
            // Não remover o botão aqui - será removido quando o callback for chamado
        };

        // Adicionar explicação
        const explanation = document.createElement('p');
        explanation.textContent = 'É necessário autorizar o acesso ao Google Drive para fazer upload das imagens. Clique no botão acima para continuar.';
        explanation.style.cssText = `
            margin-bottom: 15px;
            color: #555;
        `;

        // Montar e adicionar ao DOM
        container.appendChild(explanation);
        container.appendChild(button);
        document.body.appendChild(container);

        return button;
    }

    function removeGoogleAuthButton() {
        const container = document.getElementById('google-auth-button-container');
        if (container) {
            container.remove();
        }
    }
    // --- FIM DA MODIFICAÇÃO 2 ---

    // (Função antiga setFilePermissions mantida e chamada pela nova uploadImageToDrive)
    async function setFilePermissions(fileId) {
      // Verifica se temos token, senão não pode fazer a chamada
      if (!accessToken) {
         console.error("Não é possível definir permissões: token de acesso ausente.");
         return false; // Falha silenciosa aqui, erro já foi tratado no upload?
      }

      try {
        const response = await fetch(
          `https://www.googleapis.com/drive/v3/files/${fileId}/permissions`,
          {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${accessToken}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              role: 'reader', // Permissão de leitura
              type: 'anyone'  // Para qualquer pessoa com o link
            })
          }
        );

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error(`Erro ${response.status} ao definir permissões para fileId ${fileId}:`, errorData);
             // Se for 401, limpar token? Ou deixar uploadFileToDrive tratar?
             if (response.status === 401) {
                 accessToken = null; // Limpa token se não autorizado
             }
            return false; // Indica falha
        }

        console.log(`Permissão 'anyone' com 'reader' adicionada para fileId ${fileId}.`);
        return true; // Indica sucesso
      } catch (error) {
        console.error('Erro na requisição fetch ao configurar permissões:', error);
        return false; // Indica falha
      }
    }

    // --- INÍCIO DAS FUNÇÕES ORIGINAIS (MODIFICADA submitMaintenance) ---

    // ATUALIZAÇÃO 1.a: Modificar a função de compressão de imagem
    function compressImage(base64Data, maxSize = 300, quality = 0.5) { // Qualidade alterada para 0.5
      return new Promise((resolve, reject) => {
        try {
          // Criar uma imagem temporária
          const img = new Image();

          // Configurar o carregamento da imagem
          img.onload = function() {
            // Criar canvas para redimensionar
            const canvas = document.createElement('canvas');

            // Calcular novas dimensões mantendo a proporção
            let width = img.width;
            let height = img.height;

             // Evitar divisão por zero ou dimensões inválidas
             if (width <= 0 || height <= 0) {
                 console.warn("Dimensões inválidas da imagem original:", width, height);
                 return reject(new Error('Dimensões da imagem inválidas para compressão'));
             }


            if (width > height) {
              if (width > maxSize) {
                height = Math.round(height * (maxSize / width));
                width = maxSize;
              }
            } else {
              if (height > maxSize) {
                width = Math.round(width * (maxSize / height));
                height = maxSize;
              }
            }

             // Garantir que as dimensões não sejam zero após o cálculo
             width = Math.max(1, width);
             height = Math.max(1, height);


            // Configurar canvas com as novas dimensões
            canvas.width = width;
            canvas.height = height;

            // Desenhar imagem redimensionada
            const ctx = canvas.getContext('2d');
            // Adicionar um fundo branco caso a imagem seja transparente (PNG) e o formato de saída seja JPEG
             if (base64Data.startsWith('data:image/png') || !base64Data.startsWith('data:')) { // Assume PNG ou sem tipo
                 ctx.fillStyle = "#FFFFFF"; // Cor de fundo branca
                 ctx.fillRect(0, 0, width, height);
             }

            ctx.drawImage(img, 0, 0, width, height);

            // Converter para base64 com compressão (usar image/jpeg para compressão com perda)
            // Se a original for PNG e quisermos manter transparência, usar 'image/png', mas a compressão será menor.
            // Vamos padronizar para JPEG para garantir tamanho menor.
            let compressedBase64;
            try {
                compressedBase64 = canvas.toDataURL('image/jpeg', quality);
                 // Verificar se o resultado é válido
                 if (!compressedBase64 || compressedBase64.length < 100) {
                     throw new Error("Canvas toDataURL retornou resultado inválido.");
                 }
            } catch (canvasError) {
                 console.error("Erro ao converter canvas para JPEG:", canvasError);
                 return reject(new Error('Erro ao gerar imagem comprimida (JPEG)'));
            }

            // Resolver com a imagem comprimida
            resolve(compressedBase64);
          };

          // Configurar tratamento de erro no carregamento da imagem original
          img.onerror = function(err) {
            console.error("Erro ao carregar imagem para compressão. SRC:", base64Data.substring(0,50)+"...");
            reject(new Error('Erro ao carregar imagem base para compressão'));
          };

          // Carregar a imagem (precisa ser um Data URL válido)
          if (typeof base64Data === 'string' && base64Data.startsWith('data:image')) {
             img.src = base64Data;
          } else {
             console.error("Formato inválido para compressImage, esperado Data URL. Recebido:", typeof base64Data);
             reject(new Error('Formato de imagem inválido para compressão (esperado Data URL)'));
          }

        } catch (error) {
           console.error("Erro inesperado em compressImage:", error);
          reject(error);
        }
      });
    }

    // ***************************************************************
    // ***** INÍCIO DAS NOVAS FUNÇÕES DE UPLOAD (SEÇÃO 2.1) *****
    // ***************************************************************

    // Função melhorada para upload direto ao Drive
    async function uploadImageToDrive(imageBlob, folderId, fileName) {
      try {
        console.log(`Iniciando upload da imagem para a pasta ${folderId}...`);

        // 1. Obter token de autorização do backend
        const authResult = await callAPI('getUploadUrl', { folderId }); // Assume que getUploadUrl retorna o accessToken E valida o folderId

        if (!authResult || !authResult.success || !authResult.accessToken) {
          // Se o token não veio via backend, tentar obter diretamente via cliente (com popup)
          console.warn("Falha ao obter token via backend. Tentando obter via cliente...");

          // Lógica de obter token via cliente (similar à função uploadFileToDrive antiga)
          if (!gapiInited || !gisInited || !tokenClient) {
            throw new Error("APIs do Google não inicializadas corretamente.");
          }
          if (!accessToken) { // Se não temos token nem do backend nem local
            console.log("Solicitando token de acesso ao usuário...");
            showLoading(true, 'Aguardando permissão do Google...');
            const tokenObtained = await new Promise((resolve) => {
                const originalCallback = tokenClient.callback;
                let popupBlocked = false;
                let popupCheckTimeout = setTimeout(() => { popupBlocked = true; checkPopupBlocked(); }, 300);

                const checkPopupBlocked = () => {
                   if(!popupBlocked) return; // Evita rodar múltiplas vezes
                   console.warn("Possível bloqueio de popup.");
                   clearTimeout(popupCheckTimeout);
                   showNotification("O popup de autorização do Google pode ter sido bloqueado. Clique no botão 'Autorizar Google Drive' que aparecerá.", "warning", 10000);
                   showGoogleAuthButton(() => { tokenClient.requestAccessToken({prompt: 'consent'}); });
                   resolve(false);
                };

                tokenClient.callback = (resp) => {
                    clearTimeout(popupCheckTimeout);
                    removeGoogleAuthButton();
                    originalCallback(resp); // Chama o callback original para logar e setar accessToken
                    resolve(resp.error === undefined); // Resolve true se sucesso, false se erro
                };
                try { tokenClient.requestAccessToken({prompt: ''}); } catch (e) { checkPopupBlocked(); }
            });
            showLoading(false);
            if (!tokenObtained || !accessToken) {
              throw new Error("Falha ao obter autorização do Google. Tente novamente.");
            }
          }
          // Se chegou aqui, temos o token do cliente
          authResult.accessToken = accessToken; // Usa o token obtido do cliente
        }
        // Se o backend falhou mas obtivemos token do cliente, continuamos
        // Se não, o erro inicial será lançado

        // 2. Preparar nome do arquivo
        const fileTimestamp = Date.now();
        const fileExt = imageBlob.type ? imageBlob.type.split('/')[1] || 'jpg' : 'jpg';
        const finalFileName = fileName || `imagem_${fileTimestamp}.${fileExt}`;

        // 3. Preparar metadados do arquivo
        const metadata = {
          name: finalFileName,
          parents: [folderId],
          mimeType: imageBlob.type || 'image/jpeg'
        };

        // 4. Criar FormData para upload
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', imageBlob);

        console.log(`Enviando arquivo "${finalFileName}" para o Drive...`);

        // 5. Fazer upload direto para a API do Drive
        const response = await fetch(
          'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
          {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${authResult.accessToken}` }, // Usa o token (do backend ou cliente)
            body: form
          }
        );

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
           // Tratar erro 401 (token inválido/expirado) limpando o token local
           if (response.status === 401) {
               console.warn("Erro 401 - Token inválido/expirado. Limpando token local.");
               accessToken = null; // Força nova autenticação na próxima tentativa
           }
          throw new Error(`Erro de upload (${response.status}): ${errorData.error?.message || response.statusText}`);
        }

        // 6. Processar resposta do upload
        const uploadResult = await response.json();

        console.log(`Arquivo enviado com sucesso para o Drive. ID: ${uploadResult.id}`);

        // 7. Configurar permissão de compartilhamento (visualização pública)
        try {
          const permissionResponse = await fetch(
            `https://www.googleapis.com/drive/v3/files/${uploadResult.id}/permissions`,
            {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${authResult.accessToken}`, // Usa o mesmo token
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                role: 'reader',
                type: 'anyone'
              })
            }
          );

          if (!permissionResponse.ok) {
              const permErrorData = await permissionResponse.json().catch(() => ({}));
             // Se o erro for 401 aqui também, limpar token
             if (permissionResponse.status === 401) {
                 accessToken = null;
             }
             console.warn(`Aviso: Não foi possível definir permissões públicas para o arquivo ${uploadResult.id}. Status: ${permissionResponse.status}. Erro: ${permErrorData.error?.message || permissionResponse.statusText}`);
          } else {
              console.log(`Permissões configuradas para ${uploadResult.id}.`);
          }
        } catch (permError) {
          console.warn(`Erro ao configurar permissões: ${permError.message}`);
          // Continuamos mesmo se a configuração de permissão falhar
        }

        // 8. Gerar URL para visualização
        const fileUrl = `https://drive.google.com/uc?export=view&id=${uploadResult.id}`;

        // 9. Registrar o arquivo enviado no backend (Assumindo que selectedMaintenanceId está correto)
         if (!selectedMaintenanceId) {
              console.warn("`selectedMaintenanceId` não definido ao tentar registrar arquivo. O registro pode falhar.");
         }
         try {
            await callAPI('registerUploadedFile', {
              fileId: uploadResult.id,
              fileName: uploadResult.name,
              fileUrl: fileUrl,
              maintenanceId: selectedMaintenanceId // ID da manutenção atual
            });
            console.log(`Arquivo ${uploadResult.name} registrado no backend para manutenção ${selectedMaintenanceId}.`);
         } catch (registerError) {
            console.error(`Falha ao registrar arquivo ${uploadResult.name} no backend: ${registerError.message}`);
             // Decidir se isso deve impedir o sucesso geral? Por enquanto, apenas logar.
             showNotification(`Aviso: Imagem ${uploadResult.name} salva no Drive, mas falha ao registrar no sistema.`, 'warning');
         }


        return {
          success: true,
          fileId: uploadResult.id,
          url: fileUrl,
          name: uploadResult.name
        };

      } catch (error) {
        console.error('Erro no upload:', error);
        // Garantir que o token seja limpo em caso de erro de autorização
        if (error.message && (error.message.includes("autorização") || error.message.includes("token") || error.message.includes("401"))) {
           accessToken = null;
        }
        return {
          success: false,
          message: error.message || 'Erro desconhecido no upload'
        };
      }
    }

    // Função para fazer upload de múltiplas imagens
    async function uploadAllImagesToDrive(images, maintenanceId, folderId) {
      console.log(`Iniciando upload de ${images.length} imagens para pasta ${folderId}...`);
      showLoading(true, 'Preparando upload de imagens...');

      try {
        const results = [];
        const errors = [];
        let successCount = 0;

        // Salvar o ID da manutenção atual para o registro das imagens
        selectedMaintenanceId = maintenanceId;

        for (let i = 0; i < images.length; i++) {
          if (!images[i]) continue; // Pula imagens nulas/removidas

          try {
            showLoading(true, `Enviando imagem ${i+1}/${images.length}...`);

            // Converter para blob
            const blob = await base64ToBlob(images[i]);

            // Nome do arquivo sequencial
            const fileName = `manutenção_${maintenanceId}_imagem_${i+1}.jpg`;

            // Fazer upload
            const result = await uploadImageToDrive(blob, folderId, fileName);

            if (result.success) {
              results.push(result.url);
              successCount++;
            } else {
              errors.push({ index: i, error: result.message });
              console.error(`Falha no upload da imagem ${i+1}:`, result.message);
               // Mostrar notificação de erro individual? Pode ser demais.
            }

            // Pequena pausa entre uploads
            await new Promise(resolve => setTimeout(resolve, 300));

          } catch (imgError) {
            errors.push({ index: i, error: imgError.message });
            console.error(`Erro ao processar imagem ${i+1}:`, imgError);
          }
        } // Fim do loop for

        return {
          success: errors.length === 0, // Sucesso total se não houver erros
          message: errors.length > 0
            ? `Falha em ${errors.length} de ${images.length} imagens`
            : 'Todas as imagens enviadas com sucesso',
          urls: results,
          errors: errors,
          successCount: successCount
        };

      } catch (error) {
        console.error('Erro geral no upload de imagens:', error);
        return {
          success: false,
          message: error.message || 'Erro inesperado no processo de upload',
          urls: [],
          errors: [{ index: -1, error: error.message }],
          successCount: 0
        };
      } finally {
        showLoading(false);
      }
    }

    // ***************************************************************
    // ***** FIM DAS NOVAS FUNÇÕES DE UPLOAD (SEÇÃO 2.1) *****
    // ***************************************************************


    // Função callAPI original (mantida para outras chamadas que não precisam de chunking/retry)
    function callAPI(action, data = {}) {
      // Para debug
      console.log(`Chamando API (JSONP): ${action}`);
      let localScript = null; // Use uma variável local para o script

      return new Promise((resolve, reject) => {
        try {
          // Nome único para a função de callback
          const callbackName = 'jsonp_callback_' + Math.round(100000 * Math.random());

          // Criar uma função global que será chamada pelo script
          window[callbackName] = function(response) {
            // Remover o script após execução
            if (localScript && localScript.parentNode) {
              localScript.parentNode.removeChild(localScript);
            }

            // Limpar o callback global
            try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }


            // Verificar se a resposta tem um erro vindo do backend
            if (response && response.error) {
              console.error(`Erro na resposta da API (${action}): ${response.message || response.error}`);
              reject(new Error(response.message || `Erro na API (${action}): ${response.error}`)); // Use a mensagem de erro do backend
              return;
            }
             // Verificar resposta inesperada (não é objeto, etc) - pode indicar erro JSONP
             if (typeof response !== 'object' || response === null) {
                 console.error(`Resposta inesperada da API (${action}):`, response);
                 reject(new Error(`Resposta inválida ou erro de comunicação com a API (${action}).`));
                 return;
             }


            // Resolver a promessa com os dados
            resolve(response);
          };

          // Se a ação for saveVerification com imagens, verificar tamanho (saveMaintenance agora usa outra lógica)
          if (action === 'saveVerification' && data.images && data.images.length > 0) {
             console.log(`Preparando envio para ${action} com ${data.images.length} imagens...`);

             let dataToSend = { ...data };
             let jsonSize;
             try {
                jsonSize = JSON.stringify(dataToSend).length;
                console.log("Tamanho inicial estimado dos dados:", (jsonSize / 1024 / 1024).toFixed(2), "MB");
                 // A compressão já deve ter ocorrido antes de chamar callAPI aqui.
                 // Verificar limite JSONP (aproximado)
                 if (jsonSize > 1800000) { // ~1.8MB como limite mais seguro para JSONP GET payload
                    console.error("Payload de dados de verificação muito grande para JSONP GET:", jsonSize);
                    try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }
                    reject(new Error('Dados da verificação (incluindo fotos) são muito grandes. Tente com menos fotos ou fotos menores.'));
                    return;
                 }

             } catch (e) {
                 console.error("Erro ao estimar tamanho dos dados de verificação:", e);
                  try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }
                 reject(new Error("Erro ao processar dados da verificação para envio."));
                 return;
             }

             sendRequest(dataToSend, action, callbackName);

          } else {
            // Para outras ações ou sem imagens, enviar normalmente
            sendRequest(data, action, callbackName);
          }

          // Função interna para evitar duplicação
          function sendRequest(payload, apiAction, cbName) {
            try {
                // Converter dados para string
                let dataStr = encodeURIComponent(JSON.stringify(payload));

                // Construir URL com parâmetros
                // Adicionar parâmetro extra para evitar cache em algumas redes/browsers
                const url = `${API_URL}?action=${apiAction}&data=${dataStr}&callback=${cbName}&t=${Date.now()}`;


                // AVISO: JSONP tem limites de tamanho de URL (geralmente ~2KB a 8KB, varia muito).
                // Dados grandes (mesmo após compressão) enviados via GET desta forma podem falhar.
                // A estratégia sequentialAPICall com POST simulado ou upload direto (Drive) é MELHOR.
                if (url.length > 8000) { // Limite mais realista, mas ainda arriscado para JSONP
                    console.warn(`URL da requisição JSONP (${apiAction}) muito longa (${url.length} caracteres). Pode falhar.`);
                    // Não rejeitar ainda, mas avisar. A falha ocorrerá no browser/servidor.
                }
                 if (url.length > 15000) { // Limite mais perigoso
                      console.error("URL da requisição JSONP perigosamente longa:", url.length, "caracteres.");
                      try { delete window[cbName]; } catch (e) { window[cbName] = undefined; } // Limpar callback
                      reject(new Error(`Payload de dados muito grande para a requisição ${apiAction} via GET (JSONP).`));
                      return;
                 }


                // Criar elemento de script
                localScript = document.createElement('script'); // Atribui à variável local
                localScript.src = url;
                let timeoutId = null; // Timeout ID específico para esta request

                // Lidar com erros de carregamento do script (onerror)
                localScript.onerror = (event) => {
                    console.error(`Falha ao carregar script JSONP para ação: ${apiAction}. URL: ${url.substring(0, 100)}... Event:`, event);
                    // Remover o script
                    if (localScript && localScript.parentNode) {
                        localScript.parentNode.removeChild(localScript);
                    }

                    // Limpar o callback e timeout
                     try { delete window[cbName]; } catch (e) { window[cbName] = undefined; }
                    if(timeoutId) clearTimeout(timeoutId);

                    // Rejeitar a promessa com erro mais informativo
                    reject(new Error(`Falha na comunicação com a API (${apiAction}). Verifique a conexão e a URL da API. (Script Error)`));
                };

                // Definir um timeout (aumentado para permitir uploads maiores, mas ainda limitado por JSONP)
                timeoutId = setTimeout(() => {
                    console.warn(`Timeout na requisição JSONP para ação: ${apiAction} após 60 segundos. URL: ${url.substring(0,100)}...`);
                    if (localScript && localScript.parentNode) {
                        localScript.parentNode.removeChild(localScript);
                    }
                    try { delete window[cbName]; } catch (e) { window[cbName] = undefined; }
                    reject(new Error(`A API (${apiAction}) demorou muito para responder (Timeout).`));
                }, 60000); // 60 segundos

                // Substituir o handler de sucesso para limpar o timeout
                const originalCallback = window[cbName];
                window[cbName] = function(response) {
                    clearTimeout(timeoutId); // Limpa o timeout ao receber resposta
                    originalCallback(response); // Chama o callback original
                };

                // Adicionar o script ao documento para iniciar a solicitação
                console.log(`Adicionando script JSONP para ${apiAction}...`);
                document.body.appendChild(localScript);

            } catch (error) {
                console.error(`Erro dentro de sendRequest para ${apiAction}:`, error);
                 try { delete window[cbName]; } catch (e) { window[cbName] = undefined; } // Garante limpeza do callback
                reject(new Error(`Erro ao preparar a requisição para ${apiAction}: ${error.message}`));
            }
          }

        } catch (error) {
          console.error("Erro geral em callAPI:", error);
          // Tenta limpar o callback se já foi definido
           const callbackNameMatch = error.message ? error.message.match(/jsonp_callback_\d+/) : null;
           if (callbackNameMatch && window[callbackNameMatch[0]]) {
               try { delete window[callbackNameMatch[0]]; } catch(e){ window[callbackNameMatch[0]] = undefined; }
           }
          reject(error);
        }
      });
    }

    // Função para chamadas de API sequenciais (usada para criar/finalizar registro)
    // ATENÇÃO: Esta função ainda usa JSONP GET e tem limitações de tamanho de URL.
    // Não é adequada para enviar chunks de dados grandes no parâmetro 'data'.
    // É usada aqui apenas para 'createMaintenanceRecord' e 'finalizeMaintenanceRecord' que enviam poucos dados.
    function sequentialAPICall(action, data = {}) {
      console.log(`Chamando API Sequencial (JSONP): ${action}`);
      return new Promise((resolve, reject) => {
        const callbackName = 'jsonpSeqCallback_' + Date.now() + '_' + Math.floor(Math.random() * 1000000);
        let scriptElement = null; // Variável para o script dentro do escopo da Promise
        let timeoutId = null;

        // Criar função de callback global
        window[callbackName] = function(response) {
          // Limpar
          clearTimeout(timeoutId); // Limpa timeout
          if (scriptElement && scriptElement.parentNode) {
            scriptElement.parentNode.removeChild(scriptElement);
          }
          try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }

          if (response && response.error) {
            console.error(`Erro na resposta da API Sequencial (${action}):`, response);
            reject(new Error(response.message || `Erro API Sequencial (${action}): ${response.error}`)); // Usa a mensagem do erro se existir
          } else if (typeof response !== 'object' || response === null) {
             console.error(`Resposta inesperada da API Sequencial (${action}):`, response);
             reject(new Error(`Resposta inválida ou erro de comunicação com API Sequencial (${action}).`));
          } else {
            resolve(response);
          }
        };

        // Criar URL para a chamada
        let url = `${API_URL}?action=${action}&callback=${callbackName}&t=${Date.now()}`;

        // Adicionar dados se houver (codificados na URL)
        if (data && Object.keys(data).length > 0) {
          try {
             const dataStr = encodeURIComponent(JSON.stringify(data));
             // Verificar tamanho dos dados + URL base
             if ((url.length + dataStr.length + 10) > 8000) { // +10 para &data= etc.
                 console.warn(`Dados para ${action} podem tornar a URL JSONP muito longa.`);
             }
              if ((url.length + dataStr.length + 10) > 15000) {
                 console.error(`Dados para ${action} excedem o limite prático de URL JSONP.`);
                  try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }
                 reject(new Error(`Dados para ${action} são muito grandes para envio via URL.`));
                 return;
              }
             url += `&data=${dataStr}`;
          } catch (e) {
              try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; } // Limpar callback
              reject(new Error(`Erro ao serializar dados para ${action}: ${e.message}`));
              return;
          }
        }

        // Criar elemento de script
        scriptElement = document.createElement('script'); // Atribui à variável de escopo
        scriptElement.src = url;

        // Configurar tratamento de erro de carregamento do script (onerror)
        scriptElement.onerror = function(event) {
          console.error(`Falha ao carregar script JSONP sequencial para ação: ${action}. URL: ${url.substring(0,100)}... Event:`, event);
           clearTimeout(timeoutId); // Limpa timeout
          if (scriptElement && scriptElement.parentNode) {
            scriptElement.parentNode.removeChild(scriptElement);
          }
          try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }
          // Erro comum aqui pode ser URL muito longa, falha de rede, ou erro 404 na API_URL.
          reject(new Error(`Falha na comunicação com o servidor para ação: ${action} (Script Error).`));
        };

         // Adicionar um timeout para a chamada sequencial
         timeoutId = setTimeout(() => {
            console.warn(`Timeout na chamada sequencial para ${action} após 90 segundos. URL: ${url.substring(0,100)}...`);
             if (scriptElement && scriptElement.parentNode) {
                 scriptElement.parentNode.removeChild(scriptElement);
             }
             try { delete window[callbackName]; } catch (e) { window[callbackName] = undefined; }
             reject(new Error(`API Sequencial (${action}) demorou muito para responder (Timeout).`));
         }, 90000); // 90 segundos

         // Modificar callback para limpar o timeout (já feito no início do callback)

        // Adicionar ao documento
        console.log(`Adicionando script JSONP Sequencial para ${action}...`);
        document.body.appendChild(scriptElement);
      });
    }

    // A função uploadImagesSequentially ANTIGA (com chunks via JSONP) foi REMOVIDA
    // e substituída pela nova que usa uploadFileToDrive (Passo 4 das instruções).
    // As funções splitBase64IntoChunks, uploadImageInChunks e uploadImageChunkWithRetry
    // também foram REMOVIDAS pois pertenciam à estratégia antiga de chunking via JSONP.


    // ***** INÍCIO DA SUBSTITUIÇÃO DA FUNÇÃO submitMaintenance (SEÇÃO 2.2) *****
    function submitMaintenance() {
      // Mostrar loading
      showLoading(true, 'Preparando dados...');

      // Validar imagens
      const validImages = capturedImages.filter(img => img !== null);
      if (validImages.length === 0) {
        showLoading(false);
        document.getElementById('photo-warning').style.display = 'block';
        goToFormStep('maintenance', 3);
        showNotification('Por favor, adicione pelo menos uma foto na Etapa 3.', 'error');
        return;
      }
      document.getElementById('photo-warning').style.display = 'none';

      console.log("Iniciando processamento de " + validImages.length + " imagens válidas...");

      // Comprimir todas as imagens para menor tamanho
      const compressPromises = validImages.map((image, index) => {
        console.log("Comprimindo imagem " + (index + 1) + "...");
        return compressImage(image, 200, 0.3) // Usa os parâmetros da instrução
          .catch(error => {
            console.error(`Erro ao comprimir imagem ${index + 1}:`, error);
            showNotification(`Erro ao comprimir imagem ${index + 1}. A imagem original será usada.`, 'warning');
            return image; // Retorna a original em caso de erro
          });
      });

      Promise.all(compressPromises)
        .then(compressedImages => {
          console.log(compressedImages.length + " imagens prontas para envio (comprimidas ou originais).");

          // Coletar dados do formulário
          const formData = {
            equipmentId: document.getElementById('equipment-id').value,
            equipmentType: document.getElementById('equipment-type').value,
            technician: document.getElementById('technician-name').value,
            date: document.getElementById('maintenance-date').value,
            location: document.getElementById('location').value,
            maintenanceType: document.getElementById('maintenance-type').value,
            isCritical: document.getElementById('is-critical').checked,
            problemCategory: document.getElementById('problem-category').value,
            problemDescription: document.getElementById('problem-description').value,
            solutionDescription: document.getElementById('solution-description').value,
            partsReplaced: document.getElementById('parts-replaced').value || "",
            additionalNotes: document.getElementById('additional-notes').value || "",
          };

          // Validação básica dos dados do formulário
          if (!formData.equipmentId || !formData.equipmentType || !formData.technician ||
              !formData.date || !formData.location || !formData.maintenanceType ||
              !formData.problemCategory || !formData.problemDescription || !formData.solutionDescription) {
            showLoading(false);
            showNotification("Erro: Campos obrigatórios não preenchidos.", "error");
            goToFormStep('maintenance', 1); // Tenta levar para a primeira etapa
            // Adicional: Marcar campos inválidos
            validateFormStep('maintenance', 1); // Revalida etapa 1
            validateFormStep('maintenance', 2); // Revalida etapa 2
            return Promise.reject(new Error("Validação do formulário falhou"));
          }

          // ETAPA 1: Criar o registro de manutenção sem imagens
          showLoading(true, 'Enviando dados de manutenção...');
          console.log("Enviando manutenção (Etapa 1: Criar Registro)...");

          return sequentialAPICall('createMaintenanceRecord', formData)
            .then(result => {
              // Verificar se a criação foi bem-sucedida
              if (!result || !result.success || !result.id || !result.folderId) {
                const errorMsg = result ? (result.message || 'Resposta inválida do servidor.') : 'Sem resposta do servidor.';
                throw new Error(`Falha ao criar registro: ${errorMsg}`);
              }

              console.log("Registro criado com sucesso. ID: " + result.id + ", Folder ID: " + result.folderId);

              // ETAPA 2: Upload direto para o Drive usando a nova função
              showLoading(true, 'Iniciando upload de imagens...');
              return uploadAllImagesToDrive(compressedImages, result.id, result.folderId)
                .then(uploadResults => {
                  // ETAPA 3: Finalizar o registro com as URLs das imagens
                  console.log(`Finalizando registro ${result.id} após upload de ${uploadResults.successCount} imagens...`);
                  showLoading(true, 'Finalizando registro...');
                  return sequentialAPICall('finalizeMaintenanceRecord', {
                    id: result.id,
                    imageUrls: uploadResults.urls // Incluir URLs obtidas do Drive
                  }).then(finalResult => {
                    // Encapsula todos os resultados para o próximo .then
                    return {
                      createResult: result,
                      uploadResults: uploadResults,
                      finalizeResult: finalResult
                    };
                  });
                });
            })
            .then(results => { // Recebe o objeto com createResult, uploadResults, finalizeResult
              showLoading(false);

              // Verificar se houve erros parciais no upload
              if (results.uploadResults && results.uploadResults.errors && results.uploadResults.errors.length > 0) {
                showNotification(`Manutenção ID ${results.createResult.id} registrada, mas ${results.uploadResults.errors.length} imagens falharam no upload.`, 'warning');
                console.warn("Erros de upload:", results.uploadResults.errors);
              } else if (results.finalizeResult && results.finalizeResult.success) {
                showNotification('Manutenção registrada com sucesso! ID: ' + results.createResult.id, 'success');
              } else {
                // Erro na finalização ou estrutura inesperada
                 const finalErrorMsg = results.finalizeResult?.message || 'Houve um problema na finalização.';
                 showNotification(`Manutenção ID ${results.createResult.id} registrada, mas ${finalErrorMsg}`, 'warning');
                 console.error("Erro ou resposta inválida na finalização:", results.finalizeResult);
              }

              closeMaintenanceForm();
              loadDashboardData(); // Recarregar dados
            })
            .catch(error => {
              console.error("Erro no processo de submissão:", error);
              showLoading(false);

              let userMessage = `Erro ao registrar manutenção: ${error.message || 'Erro desconhecido'}`;
              if (error.message && (error.message.includes("autenticação") || error.message.includes("autorização") || error.message.includes("Google Drive"))) {
                userMessage = "Erro de autenticação com o Google Drive. Tente novamente para permitir o acesso ou contate o suporte.";
              } else if (error.message && error.message.includes("criar registro")){
                  userMessage = `Falha ao salvar dados iniciais: ${error.message}`;
              } else if (error.message && error.message.includes("Validação do formulário")){
                   userMessage = "Erro: Formulário inválido. Verifique os campos obrigatórios.";
                   // Não fechar o form neste caso? A lógica atual fecha.
              } else if (error.message && error.message.includes("API")){
                  userMessage = `Erro de comunicação com o servidor: ${error.message}`;
              }

              showNotification(userMessage, 'error');
              closeMaintenanceForm(); // Fecha mesmo em caso de erro conforme instrução original
              loadDashboardData(); // Tentar recarregar dados caso algo tenha sido salvo
            });
        })
        .catch(error => { // Erro na compressão inicial ou coleta de dados
          console.error("Erro na compressão de imagens ou coleta inicial:", error);
          showLoading(false);
          showNotification(`Erro ao processar imagens/dados: ${error.message || 'Erro desconhecido'}`, 'error');
        });
    }
    // ***** FIM DA SUBSTITUIÇÃO DA FUNÇÃO submitMaintenance (SEÇÃO 2.2) *****


    // --- FIM DAS FUNÇÕES ATUALIZADAS/ADICIONADAS ---


    // Configurar event listeners
    function setupEventListeners() {
      // Navegação por tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', function() {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

          this.classList.add('active');
          currentTab = this.getAttribute('data-tab');
          const currentTabContent = document.getElementById(`tab-${currentTab}`);
          if (currentTabContent) {
              currentTabContent.classList.add('active');
          } else {
              console.error(`Conteúdo da tab ${currentTab} não encontrado!`);
          }


          // Atualizar conteúdo da tab selecionada
          if (currentTab === 'maintenance') {
            loadMaintenanceDataIfNeeded(); // Carrega se ainda não carregou ou força recarga
          } else if (currentTab === 'verification') {
            loadVerificationDataIfNeeded(); // Carrega se ainda não carregou ou força recarga
          } else if (currentTab === 'reports') {
            updateReportsCharts(); // Apenas atualiza charts, dados são carregados sob demanda
          } else if (currentTab === 'dashboard') {
             loadDashboardData(); // Recarrega dados do dashboard ao voltar pra ele
          }
          // Parar câmeras ao mudar de aba (precaução)
          stopAllCameraStreams();
        });
      });

      // Filtros de manutenções
      document.querySelectorAll('#tab-maintenance .filter-item').forEach(filter => {
        filter.addEventListener('click', function() {
          const filterItems = this.parentElement.querySelectorAll('.filter-item');
          filterItems.forEach(f => f.classList.remove('active'));
          this.classList.add('active');
          currentMaintenanceFilter = this.getAttribute('data-filter');
          updateMaintenanceList(); // Atualiza a exibição com base nos dados já carregados
        });
      });
      // Filtros de verificações
      document.querySelectorAll('#tab-verification .filter-item').forEach(filter => {
        filter.addEventListener('click', function() {
          const filterItems = this.parentElement.querySelectorAll('.filter-item');
          filterItems.forEach(f => f.classList.remove('active'));
          this.classList.add('active');
          currentVerificationFilter = this.getAttribute('data-filter');
          updateVerificationList(); // Atualiza a exibição com base nos dados já carregados
        });
      });


      // Busca de manutenções
      document.getElementById('maintenance-search').addEventListener('input', debounce(function() {
        searchTerm = this.value; // Atualiza o termo de busca global
        updateMaintenanceList(); // Atualiza a lista de manutenção com o novo termo
      }, 300)); // Debounce para evitar atualizações a cada tecla


      // Busca de verificações
      document.getElementById('verification-search').addEventListener('input', debounce(function() {
        searchTerm = this.value; // Atualiza o termo de busca global
        updateVerificationList(); // Atualiza a lista de verificação com o novo termo
      }, 300)); // Debounce


      // Filtro de período do Dashboard
      document.getElementById('period-filter').addEventListener('change', function() {
        loadDashboardData(); // Recarrega dados do dashboard com o novo período
      });

      // Botões de refresh
       // Adiciona verificação se dashboardData existe antes de tentar renderizar
      document.getElementById('refresh-type-chart').addEventListener('click', function() {
        if (dashboardData) renderMaintenanceTypeChart(); else showNotification("Dados do dashboard ainda não carregados.", "info");
      });

      document.getElementById('refresh-status-chart').addEventListener('click', function() {
        if (dashboardData) renderMaintenanceStatusChart(); else showNotification("Dados do dashboard ainda não carregados.", "info");
      });

      document.getElementById('refresh-equipment-ranking').addEventListener('click', function() {
        if (dashboardData) updateEquipmentRanking(); else showNotification("Dados do dashboard ainda não carregados.", "info");
      });

      document.getElementById('refresh-maintenance-list').addEventListener('click', function() {
        loadMaintenanceDataIfNeeded(true); // Força recarga dos dados da API
      });

      document.getElementById('refresh-verification-list').addEventListener('click', function() {
        loadMaintenanceDataIfNeeded(true); // Força recarga dos dados (a lista de verificação depende deles)
      });

      // Botões de exportação e relatório
      document.getElementById('export-excel').addEventListener('click', function() {
        exportData('excel');
      });

      document.getElementById('export-pdf').addEventListener('click', function() {
        exportData('pdf');
      });

      document.getElementById('print-report').addEventListener('click', function() {
        // Pode ser necessário estilizar uma versão para impressão via CSS @media print
        window.print();
      });

      // Geração de relatório
      document.getElementById('generate-report').addEventListener('click', function() {
        generateReport();
      });

      // Botão de nova manutenção
      document.getElementById('new-maintenance').addEventListener('click', function() {
        openMaintenanceForm();
      });

      // Fechar formulários e modais
      document.getElementById('close-maintenance-form').addEventListener('click', function() {
        if (hasUnsavedChanges('maintenance') && !confirm('Existem dados não salvos. Deseja realmente cancelar?')) {
             return; // Não fecha se o usuário cancelar a confirmação
         }
        closeMaintenanceForm();
      });

      document.getElementById('close-verification-form').addEventListener('click', function() {
         if (hasUnsavedChanges('verification') && !confirm('Existem dados não salvos. Deseja realmente cancelar?')) {
            return;
         }
         closeVerificationForm();
      });

      document.getElementById('close-detail').addEventListener('click', function() {
        document.getElementById('detail-overlay').style.display = 'none';
      });

      document.getElementById('close-detail-btn').addEventListener('click', function() {
        document.getElementById('detail-overlay').style.display = 'none';
      });

      // Modal de imagem
      document.getElementById('closeModal').addEventListener('click', function() {
        document.getElementById('imageModal').style.display = 'none';
      });
      // Fechar modal clicando fora da imagem
      document.getElementById('imageModal').addEventListener('click', function(e) {
         if (e.target === this) { // Clicou no fundo escuro, não na imagem
             this.style.display = 'none';
         }
      });

      // Fechar formulários clicando fora deles (overlay)
      document.getElementById('maintenance-form-overlay').addEventListener('click', function(e) {
        if (e.target === this) { // Clicou no overlay, não no form-container
          if (hasUnsavedChanges('maintenance') && !confirm('Existem dados não salvos. Deseja realmente cancelar?')) {
            return;
          }
          closeMaintenanceForm();
        }
      });

      document.getElementById('verification-form-overlay').addEventListener('click', function(e) {
        if (e.target === this) {
           if (hasUnsavedChanges('verification') && !confirm('Existem dados não salvos. Deseja realmente cancelar?')) {
              return;
           }
          closeVerificationForm();
        }
      });

      document.getElementById('detail-overlay').addEventListener('click', function(e) {
        if (e.target === this) {
          document.getElementById('detail-overlay').style.display = 'none';
        }
      });

      // Navegação no formulário de manutenção
      document.getElementById('next-to-step-2').addEventListener('click', function() {
        if (validateFormStep('maintenance', 1)) {
          goToFormStep('maintenance', 2);
        }
      });

      document.getElementById('back-to-step-1').addEventListener('click', function() {
        goToFormStep('maintenance', 1);
      });

      document.getElementById('next-to-step-3').addEventListener('click', function() {
        if (validateFormStep('maintenance', 2)) {
          goToFormStep('maintenance', 3);
        }
      });

      document.getElementById('back-to-step-2').addEventListener('click', function() {
        goToFormStep('maintenance', 2);
      });

      // Cancelar formulários (botões internos)
      document.getElementById('cancel-maintenance').addEventListener('click', function() {
        if (hasUnsavedChanges('maintenance') && !confirm('Existem dados não salvos. Deseja realmente cancelar?')) {
            return;
        }
        closeMaintenanceForm();
      });

      document.getElementById('cancel-verification').addEventListener('click', function() {
        if (hasUnsavedChanges('verification') && !confirm('Existem dados não salvos. Deseja realmente cancelar?')) {
             return;
         }
        closeVerificationForm();
      });

      // Envio dos formulários
      document.getElementById('maintenance-form').addEventListener('submit', function(e) {
        e.preventDefault(); // Impedir envio padrão HTML
        // A validação da etapa 3 (ter foto) é feita dentro de submitMaintenance
        // A validação das etapas 1 e 2 ocorre ao clicar em "Próximo" e também é re-verificada em submitMaintenance
        submitMaintenance(); // Chama a função JS que agora usa upload direto para Drive
      });

      document.getElementById('verification-form').addEventListener('submit', function(e) {
        e.preventDefault();
        if (validateFormStep('verification')) { // Valida todo o form de verificação
             submitVerification();
        }
      });

      // --- Câmera Event Listeners ---
      // Manutenção
      document.getElementById('open-camera').addEventListener('click', function() {
        openCamera('camera-stream', 'camera-placeholder');
      });
      document.getElementById('take-photo').addEventListener('click', function() {
        takePhoto('camera-stream', 'captured-image');
      });
      document.getElementById('upload-photo').addEventListener('click', function() {
        document.getElementById('photo-upload').click();
      });
      document.getElementById('photo-upload').addEventListener('change', function(e) {
        handleFileUpload(e, 'captured-image');
      });

       // Verificação
      document.getElementById('verification-open-camera').addEventListener('click', function() {
        openCamera('verification-camera-stream', 'verification-camera-placeholder');
      });
      document.getElementById('verification-take-photo').addEventListener('click', function() {
        takePhoto('verification-camera-stream', 'verification-captured-image');
      });
      document.getElementById('verification-upload-photo').addEventListener('click', function() {
        document.getElementById('verification-photo-upload').click();
      });
      document.getElementById('verification-photo-upload').addEventListener('change', function(e) {
        handleFileUpload(e, 'verification-captured-image');
      });

      // Botão para verificar manutenção a partir dos detalhes
      document.getElementById('verify-maintenance-btn').addEventListener('click', function() {
        if (selectedMaintenanceId) {
          // Fechar o modal de detalhes antes de abrir o form de verificação
          document.getElementById('detail-overlay').style.display = 'none';
          // Atraso pequeno para garantir que o overlay sumiu visualmente
          setTimeout(() => {
              openVerificationForm(selectedMaintenanceId);
          }, 100);
        } else {
          showNotification("Nenhum ID de manutenção selecionado para verificação.", "error");
        }
      });
    }

    // Carregar dados do dashboard
    function loadDashboardData() {
      showLoading(true, 'Carregando dashboard...');
      const period = document.getElementById('period-filter').value;

      callAPI('getDashboardData', { period: period }) // Usa a callAPI original JSONP
        .then(data => {
          if (!data || data.error) {
             console.error("Erro ao carregar dados do dashboard:", data);
             showNotification('Erro ao carregar dados do dashboard: ' + (data ? data.message : 'Resposta inválida'), 'error');
             dashboardData = {}; // Evitar erros em funções dependentes
             // Limpar ou mostrar estado de erro no dashboard
              updateDashboardWithError();
          } else {
             dashboardData = data;
             updateDashboard();
             // Carregar listas APENAS SE AINDA NÃO TIVEREM SIDO CARREGADAS
             // Ou recarregar se a lógica exigir (ex: dashboard depende de dados frescos das listas)
             // Se o dashboard já inclui dados recentes, talvez não precise recarregar as listas aqui sempre.
              if (maintenanceList.length === 0) {
                  loadMaintenanceDataIfNeeded(true); // Carrega se estiver vazia (força para garantir dados)
              } else {
                  // Atualiza tabelas do dashboard com os dados já existentes em maintenanceList
                  updateRecentMaintenanceTable();
                  updateEquipmentRanking(); // Ranking pode vir do dashboardData ou ser calculado de maintenanceList
              }
          }
        })
        .catch(error => {
          console.error("Falha na requisição do dashboard:", error);
          showNotification('Falha ao buscar dados do dashboard: ' + error.message, 'error');
          dashboardData = {}; // Evitar erros
          updateDashboardWithError();
        })
        .finally(() => {
           showLoading(false);
        });
    }

     // Função para atualizar o dashboard em caso de erro no carregamento
    function updateDashboardWithError() {
        // Limpa os cards de resumo
        document.getElementById('total-maintenance').textContent = '-';
        document.getElementById('pending-verification').textContent = '-';
        document.getElementById('completed-verifications').textContent = '-';
        document.getElementById('critical-maintenance').textContent = '-';
        document.getElementById('verification-trend').textContent = '-';
        // Limpa tabelas e gráficos
        document.getElementById('equipment-ranking-tbody').innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--danger-color);">Erro ao carregar dados.</td></tr>';
        document.getElementById('recent-maintenance-tbody').innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--danger-color);">Erro ao carregar dados.</td></tr>';
        // Destruir ou limpar gráficos
         if (charts.maintenanceTypeChart) charts.maintenanceTypeChart.destroy();
         if (charts.maintenanceStatusChart) charts.maintenanceStatusChart.destroy();
         // Opcionalmente mostrar mensagem de erro nos containers dos gráficos
         const typeChartContainer = document.getElementById('maintenance-type-chart')?.parentElement;
         if (typeChartContainer) typeChartContainer.innerHTML = '<p style="text-align: center; color: var(--danger-color);">Erro ao carregar gráfico.</p>';
         const statusChartContainer = document.getElementById('maintenance-status-chart')?.parentElement;
         if (statusChartContainer) statusChartContainer.innerHTML = '<p style="text-align: center; color: var(--danger-color);">Erro ao carregar gráfico.</p>';
    }

    // Carregar dados de manutenções (agora com controle para não recarregar desnecessariamente)
    let isMaintenanceLoading = false;
    function loadMaintenanceDataIfNeeded(forceReload = false) {
        if ((maintenanceList.length === 0 || forceReload) && !isMaintenanceLoading) {
            loadMaintenanceData();
        } else if (isMaintenanceLoading) {
            console.log("Carregamento de manutenções já em andamento.");
        } else {
             console.log("Dados de manutenção já carregados. Usando cache local.");
             // Apenas atualiza a exibição
             updateMaintenanceList();
             updateVerificationList();
             updateRecentMaintenanceTable(); // Atualiza tabela do dashboard tbm
        }
    }

    function loadMaintenanceData() {
      if (isMaintenanceLoading) return; // Evita chamadas múltiplas
      isMaintenanceLoading = true;
      showLoading(true, 'Carregando manutenções...'); // Mostrar loading específico
      console.log("Iniciando carregamento da lista de manutenções...");

      callAPI('getMaintenanceList') // Usa a callAPI original JSONP
        .then(data => {
           if (!data || data.error) {
              console.error("Erro ao carregar lista de manutenções:", data);
              showNotification('Erro ao carregar manutenções: ' + (data ? data.message : 'Resposta inválida'), 'error');
              maintenanceList = []; // Limpa lista em caso de erro
           } else {
              maintenanceList = data.maintenances || [];
              console.log(`${maintenanceList.length} manutenções carregadas.`);
           }
           // Atualizar todas as listas/tabelas que dependem de maintenanceList
           updateMaintenanceList(); // Aba Manutenções
           updateVerificationList(); // Aba Verificações
           updateRecentMaintenanceTable(); // Tabela no Dashboard
           // Pode ser necessário atualizar o dashboard se ele depende diretamente desta lista
           // updateDashboard(); // Descomentar se necessário
        })
        .catch(error => {
           console.error("Falha na requisição da lista de manutenções:", error);
          showNotification('Falha ao buscar manutenções: ' + error.message, 'error');
           maintenanceList = [];
           // Limpar as tabelas em caso de erro
           updateMaintenanceList();
           updateVerificationList();
           updateRecentMaintenanceTable();
        })
        .finally(() => {
            isMaintenanceLoading = false;
            showLoading(false); // Esconder loading após tentativa
        });
    }

    // Carregar/Atualizar dados de verificações (depende de maintenanceList)
    function loadVerificationDataIfNeeded(forceReload = false) {
       // A lista de verificação é derivada de maintenanceList, então carregamos maintenanceList se necessário.
       loadMaintenanceDataIfNeeded(forceReload);
    }

    // (loadVerificationData foi removida pois agora depende de loadMaintenanceDataIfNeeded)


    // Atualizar o dashboard com os dados carregados
    function updateDashboard() {
      if (!dashboardData || typeof dashboardData !== 'object') {
          console.warn("Tentando atualizar dashboard sem dados válidos.");
          updateDashboardWithError(); // Mostra estado de erro
          return;
      }
      console.log("Atualizando componentes do dashboard...");
      updateSummaryCards();
      updateEquipmentRanking(); // Usar dados do dashboardData se disponíveis
      updateRecentMaintenanceTable(); // Usar dados de maintenanceList (já deve estar carregada ou sendo carregada)
      renderCharts(); // Renderiza ou atualiza os gráficos do dashboard
    }

    // Atualizar cards de resumo
    function updateSummaryCards() {
      const summary = dashboardData.summary || {};
      document.getElementById('total-maintenance').textContent = summary.totalMaintenance?.toString() ?? '-';
      document.getElementById('pending-verification').textContent = summary.pendingVerification?.toString() ?? '-';
      document.getElementById('completed-verifications').textContent = summary.completedVerifications?.toString() ?? '-';
      document.getElementById('critical-maintenance').textContent = summary.criticalMaintenance?.toString() ?? '-';

      const trend = summary.verificationTrend; // Pode ser null ou undefined
      const trendElement = document.getElementById('verification-trend');
      if (typeof trend === 'number' && !isNaN(trend)) {
          trendElement.textContent = trend >= 0 ? `+${trend.toFixed(1)}%` : `${trend.toFixed(1)}%`;
          trendElement.className = 'card-trend ' + (trend >= 0 ? 'trend-up' : 'trend-down');
      } else {
          trendElement.textContent = '-';
          trendElement.className = 'card-trend'; // Sem classe de cor
      }

    }

    // Atualizar ranking de equipamentos (usa dados do dashboard se existirem)
    function updateEquipmentRanking() {
      const tbody = document.getElementById('equipment-ranking-tbody');
      tbody.innerHTML = ''; // Limpa antes de preencher

      // Verifica se dashboardData e a propriedade ranking existem
       if (!dashboardData || !Array.isArray(dashboardData.equipmentRanking)) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Dados de ranking indisponíveis.</td></tr>';
            console.warn("Dados de ranking não encontrados em dashboardData");
            return;
       }

      const ranking = dashboardData.equipmentRanking;

      if (ranking.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Nenhum equipamento encontrado no período.</td></tr>';
        return;
      }

      // Limitar aos top 5 ou 10?
      const topRanking = ranking.slice(0, 10); // Exibe os 10 primeiros

      topRanking.forEach(equipment => {
         // Validar dados de cada equipamento antes de usar
         const eqId = equipment.id || 'ID Desconhecido';
         const eqType = equipment.type || 'Tipo Desconhecido';
         const count = equipment.maintenanceCount || 0;
         const lastDate = formatDate(equipment.lastMaintenance); // Formata ou retorna '-'
         const status = equipment.status || 'Status Desconhecido';
         const statusClass = getStatusClass(status);

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${eqId}</td>
          <td>${eqType}</td>
          <td>${count}</td>
          <td>${lastDate}</td>
          <td><span class="status-badge status-${statusClass}">${status}</span></td>
        `;
        tbody.appendChild(row);
      });
    }

    // Atualizar tabela de manutenções recentes (no Dashboard)
    function updateRecentMaintenanceTable() {
      const tbody = document.getElementById('recent-maintenance-tbody');
      tbody.innerHTML = ''; // Limpa

      if (!Array.isArray(maintenanceList)) {
         tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--danger-color);">Erro ao carregar lista de manutenções.</td></tr>';
        return;
      }
      if (maintenanceList.length === 0) {
         tbody.innerHTML = '<tr><td colspan="7" style="text-align: center;">Nenhuma manutenção registrada ainda.</td></tr>';
        return;
      }

      // Ordena por data de registro (mais recente primeiro) e pega as 5 primeiras
      const recentMaintenances = [...maintenanceList]
        .sort((a, b) => {
             const dateA = new Date(a.registrationDate || a.date || 0); // Usa 0 se data for inválida
             const dateB = new Date(b.registrationDate || b.date || 0);
             return dateB - dateA; // Mais recente primeiro
         })
        .slice(0, 5); // Limitar a 5

       if (recentMaintenances.length === 0) { // Pode acontecer se as datas forem inválidas
         tbody.innerHTML = '<tr><td colspan="7" style="text-align: center;">Nenhuma manutenção recente encontrada.</td></tr>';
        return;
      }

      recentMaintenances.forEach(m => {
         // Validação e valores padrão para cada campo
         const id = m.id || 'N/A';
         const equipmentId = m.equipmentId || '-';
         const type = m.maintenanceType || m.type || 'N/A'; // Usa maintenanceType se existir, senão type
         const regDate = formatDate(m.registrationDate || m.date, true); // Inclui hora
         const tech = m.technician || '-';
         const status = m.status || 'Pendente'; // Assume Pendente se não especificado
         const statusClass = getStatusClass(status);


        const row = document.createElement('tr');
        // Usar textContent para segurança contra XSS, exceto onde HTML é necessário (botões)
        row.innerHTML = `
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><span class="status-badge status-${statusClass}"></span></td>
          <td>
            <button class="btn-icon view-maintenance" data-id="${id}" title="Ver detalhes">👁️</button>
            ${status === 'Pendente' ? `<button class="btn-icon verify-maintenance" data-id="${id}" title="Verificar">✓</button>` : ''}
          </td>
        `;
         // Preencher com textContent
         row.cells[0].textContent = id;
         row.cells[1].textContent = equipmentId;
         row.cells[2].textContent = type;
         row.cells[3].textContent = regDate;
         row.cells[4].textContent = tech;
         row.cells[5].querySelector('.status-badge').textContent = status; // Atualiza texto dentro do span

        tbody.appendChild(row);
      });

      addMaintenanceActionListeners(tbody); // Reatribuir listeners aos novos botões
    }

    // Atualizar lista de manutenções (na Aba Manutenções)
    function updateMaintenanceList() {
      const tbody = document.getElementById('maintenance-tbody');
      tbody.innerHTML = ''; // Limpa
      // Usa o termo de busca global e o filtro da aba de manutenção
      const currentSearch = document.getElementById('maintenance-search').value; // Pega valor atual do input

       if (!Array.isArray(maintenanceList)) {
         tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--danger-color);">Erro ao carregar lista de manutenções.</td></tr>';
        return;
      }

      const filtered = filterMaintenances(maintenanceList, currentMaintenanceFilter, currentSearch);

      if (filtered.length === 0) {
        tbody.innerHTML = `<tr><td colspan="7" style="text-align: center;">Nenhuma manutenção encontrada ${currentSearch ? 'para "' + currentSearch + '"' : ''} ${currentMaintenanceFilter !== 'all' ? 'com status "' + currentMaintenanceFilter + '"' : ''}.</td></tr>`;
        return;
      }

      filtered.forEach(m => {
         // Validação e valores padrão
         const id = m.id || 'N/A';
         const equipmentId = m.equipmentId || '-';
         const type = m.maintenanceType || m.type || 'N/A';
         const regDate = formatDate(m.registrationDate || m.date, true);
         const tech = m.technician || '-';
         const status = m.status || 'Pendente';
         const statusClass = getStatusClass(status);

        const row = document.createElement('tr');
         row.innerHTML = `
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><span class="status-badge status-${statusClass}"></span></td>
          <td>
            <button class="btn-icon view-maintenance" data-id="${id}" title="Ver detalhes">👁️</button>
            ${status === 'Pendente' ? `<button class="btn-icon verify-maintenance" data-id="${id}" title="Verificar">✓</button>` : ''}
          </td>
        `;
         // Preencher com textContent
         row.cells[0].textContent = id;
         row.cells[1].textContent = equipmentId;
         row.cells[2].textContent = type;
         row.cells[3].textContent = regDate;
         row.cells[4].textContent = tech;
         row.cells[5].querySelector('.status-badge').textContent = status;

        tbody.appendChild(row);
      });

      addMaintenanceActionListeners(tbody);
    }

    // Adicionar event listeners para os botões de ação das manutenções (Ver/Verificar)
    // Recebe o tbody como parâmetro para adicionar listeners apenas aos botões dentro dele
    function addMaintenanceActionListeners(tbodyElement) {
      if (!tbodyElement) return;

      // Técnica de delegação de eventos para melhor performance e evitar múltiplos listeners
      tbodyElement.removeEventListener('click', handleTableButtonClick); // Remove listener antigo se houver
      tbodyElement.addEventListener('click', handleTableButtonClick);
    }

    // Handler unificado para cliques nos botões da tabela
    function handleTableButtonClick(event) {
        const target = event.target.closest('button.btn-icon'); // Encontra o botão clicado ou seu pai se clicou no ícone
        if (!target) return; // Sai se não clicou em um botão esperado

        const id = target.getAttribute('data-id');
        if (!id) {
            console.warn("Botão clicado não possui data-id.");
            return;
        }

        if (target.classList.contains('view-maintenance')) {
            console.log(`Clicou em Ver Detalhes para ID: ${id}`);
            viewMaintenanceDetails(id);
        } else if (target.classList.contains('verify-maintenance')) {
            console.log(`Clicou em Verificar para ID: ${id}`);
            openVerificationForm(id);
        }
    }


    // Atualizar lista de verificações (na Aba Verificações)
    function updateVerificationList() {
      const tbody = document.getElementById('verification-tbody');
      tbody.innerHTML = ''; // Limpa
      // Usa o termo de busca global e o filtro da aba de verificação
      const currentSearch = document.getElementById('verification-search').value; // Pega valor atual

       if (!Array.isArray(maintenanceList)) {
         tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: var(--danger-color);">Erro ao carregar lista de manutenções.</td></tr>';
        return;
      }

      const pending = filterVerifications(maintenanceList, currentVerificationFilter, currentSearch);

      if (pending.length === 0) {
         tbody.innerHTML = `<tr><td colspan="7" style="text-align: center;">Nenhuma verificação encontrada ${currentSearch ? 'para "' + currentSearch + '"' : ''} ${currentVerificationFilter !== 'all' ? 'com filtro "' + currentVerificationFilter + '"' : ''}.</td></tr>`;
        return;
      }

      pending.forEach(m => {
         // Validação e valores padrão
         const id = m.id || 'N/A';
         const equipmentId = m.equipmentId || '-';
         const type = m.maintenanceType || m.type || 'N/A';
         const mainDate = formatDate(m.date); // Data da manutenção original
         const tech = m.technician || '-';
         const status = m.status || 'Pendente';
         const statusClass = getStatusClass(status);

        const row = document.createElement('tr');
        row.innerHTML = `
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td><span class="status-badge status-${statusClass}"></span></td>
          <td>
            <button class="btn-icon view-maintenance" data-id="${id}" title="Ver detalhes">👁️</button>
            ${status === 'Pendente' ? `<button class="btn-icon verify-maintenance" data-id="${id}" title="Verificar">✓</button>` : ''}
          </td>
        `;
         // Preencher com textContent
         row.cells[0].textContent = id;
         row.cells[1].textContent = equipmentId;
         row.cells[2].textContent = type;
         row.cells[3].textContent = mainDate;
         row.cells[4].textContent = tech;
         row.cells[5].querySelector('.status-badge').textContent = status;

        tbody.appendChild(row);
      });

      addMaintenanceActionListeners(tbody); // Usa o mesmo handler de delegação
    }

    // Renderizar todos os gráficos do dashboard
    function renderCharts() {
       // Garante que os dados estejam disponíveis
       if (!dashboardData || typeof dashboardData !== 'object') {
           console.warn("Tentando renderizar gráficos do dashboard sem dados.");
           // Opcional: Limpar áreas dos gráficos
            const typeChartContainer = document.getElementById('maintenance-type-chart')?.parentElement;
            if (typeChartContainer) typeChartContainer.innerHTML = '<canvas id="maintenance-type-chart"></canvas>'; // Recria canvas vazio
            const statusChartContainer = document.getElementById('maintenance-status-chart')?.parentElement;
            if (statusChartContainer) statusChartContainer.innerHTML = '<canvas id="maintenance-status-chart"></canvas>'; // Recria canvas vazio
           return;
       }
      renderMaintenanceTypeChart();
      renderMaintenanceStatusChart();
      // Gráficos de relatórios são renderizados/atualizados separadamente
    }

    // Renderizar/Atualizar gráfico de tipos de manutenção
    function renderMaintenanceTypeChart() {
      const canvas = document.getElementById('maintenance-type-chart');
      // Verifica se canvas existe e se há dados no dashboardData
       if (!canvas || !dashboardData || !Array.isArray(dashboardData.maintenanceTypes) || dashboardData.maintenanceTypes.length === 0) {
            console.warn("Não é possível renderizar gráfico de tipos: canvas não encontrado ou dados ausentes/vazios.");
            const container = canvas?.parentElement;
            if (container) container.innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 20px;">Nenhum dado de tipo de manutenção para exibir.</p>';
            if (charts.maintenanceTypeChart) { charts.maintenanceTypeChart.destroy(); charts.maintenanceTypeChart = null;} // Limpa instância antiga
            return;
       }
      const ctx = canvas.getContext('2d');

      // Destroi gráfico anterior se existir
      if (charts.maintenanceTypeChart) {
           charts.maintenanceTypeChart.destroy();
           charts.maintenanceTypeChart = null; // Limpa referência
      }


      // Processa os dados recebidos
      const typesData = dashboardData.maintenanceTypes.reduce((acc, item) => {
           // Garante que o tipo e a contagem são válidos
           if (item && typeof item.type === 'string' && typeof item.count === 'number') {
               acc[item.type] = (acc[item.type] || 0) + item.count; // Acumula caso haja tipos duplicados
           }
          return acc;
        }, {});

        // Define cores padrão
        const defaultColors = ['#0d6efd', '#6f42c1', '#fd7e14', '#20c997', '#dc3545', '#ffc107', '#6c757d', '#17a2b8'];
        const labels = Object.keys(typesData);
        const dataValues = Object.values(typesData);
        const backgroundColors = labels.map((_, index) => defaultColors[index % defaultColors.length]); // Rotaciona cores


      // Cria o novo gráfico
      charts.maintenanceTypeChart = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: dataValues,
            backgroundColor: backgroundColors,
            borderWidth: 1,
            borderColor: '#fff' // Borda branca para separar fatias
          }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                 legend: { position: 'right', labels: { boxWidth: 12 } },
                 tooltip: {
                      callbacks: { // Formata tooltip para mostrar porcentagem
                           label: function(context) {
                                let label = context.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed !== null) {
                                     label += context.formattedValue;
                                     const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                     const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) + '%' : '0%';
                                     label += ` (${percentage})`;
                                }
                                return label;
                           }
                      }
                 },
                 title: { // Adiciona título ao gráfico
                     display: false, // Já temos título na seção
                     // text: 'Manutenções por Tipo'
                 }
             }
         }
      });
    }

    // Renderizar/Atualizar gráfico de status das manutenções
    function renderMaintenanceStatusChart() {
        const canvas = document.getElementById('maintenance-status-chart');
        // Verifica canvas e dados
         if (!canvas || !dashboardData || !Array.isArray(dashboardData.maintenanceStatuses) || dashboardData.maintenanceStatuses.length === 0) {
             console.warn("Não é possível renderizar gráfico de status: canvas não encontrado ou dados ausentes/vazios.");
             const container = canvas?.parentElement;
             if (container) container.innerHTML = '<p style="text-align: center; color: var(--text-light); padding: 20px;">Nenhum dado de status para exibir.</p>';
              if (charts.maintenanceStatusChart) { charts.maintenanceStatusChart.destroy(); charts.maintenanceStatusChart = null; }
             return;
        }
        const ctx = canvas.getContext('2d');

        // Destroi gráfico anterior
        if (charts.maintenanceStatusChart) {
             charts.maintenanceStatusChart.destroy();
             charts.maintenanceStatusChart = null;
        }


        // Processa dados
        const statusData = dashboardData.maintenanceStatuses.reduce((acc, item) => {
           if (item && typeof item.status === 'string' && typeof item.count === 'number') {
               // Normaliza status conhecidos para agrupamento (opcional)
               const normalizedStatus = normalizeStatus(item.status);
               acc[normalizedStatus] = (acc[normalizedStatus] || 0) + item.count;
           }
          return acc;
        }, {});

         // Mapeamento de status para cores
         const statusColors = {
            'Pendente': '#ffc107', // Amarelo
            'Verificado': '#0d6efd', // Azul (inclui Aprovado, Ajustes)
            'Concluído': '#28a745', // Verde
            'Reprovado': '#dc3545', // Vermelho
            'Outro': '#6c757d' // Cinza para desconhecido/outro
        };

        const labels = Object.keys(statusData);
        const dataValues = Object.values(statusData);
        // Obtem cores com base no status normalizado
        const backgroundColors = labels.map(label => statusColors[label] || statusColors['Outro']);


        // Cria novo gráfico
        charts.maintenanceStatusChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: dataValues,
                    backgroundColor: backgroundColors,
                    borderWidth: 1,
                    borderColor: '#fff'
                }]
            },
            options: {
                 responsive: true,
                 maintainAspectRatio: false,
                 plugins: {
                      legend: { position: 'right', labels: { boxWidth: 12 } },
                      tooltip: {
                          callbacks: { // Formata tooltip para mostrar porcentagem
                               label: function(context) {
                                    let label = context.label || '';
                                    if (label) { label += ': '; }
                                    if (context.parsed !== null) {
                                         label += context.formattedValue;
                                         const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                         const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) + '%' : '0%';
                                         label += ` (${percentage})`;
                                    }
                                    return label;
                               }
                          }
                     },
                     title: { display: false }
                  }
            }
        });
    }

     // Helper para normalizar status (opcional, para agrupar 'Verificado', 'Aprovado', 'Ajustes')
     function normalizeStatus(status) {
         const lowerStatus = status ? status.toLowerCase() : 'pendente';
         if (['verificado', 'aprovado', 'ajustes'].includes(lowerStatus)) {
             return 'Verificado';
         }
         if (lowerStatus === 'concluido') {
             return 'Concluído';
         }
         if (lowerStatus === 'reprovado') {
              return 'Reprovado'; // Garante capitalização
         }
          // Capitaliza a primeira letra para consistência
          return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();
     }


    // Atualizar gráficos da aba de relatórios (placeholder)
    function updateReportsCharts() {
      // Esta função é chamada ao mudar para a aba de relatórios.
      // Idealmente, ela deveria verificar se os dados do último relatório gerado ainda são válidos
      // ou se precisa limpar/mostrar mensagem para gerar um novo.
      console.log("Aba Relatórios ativada. Renderizando gráficos (com dados de exemplo se nenhum relatório foi gerado).");
      // Renderiza com dados de exemplo se as instâncias de chart ainda não existem
      // Se já existem (de um relatório anterior), mantém eles visíveis.
      // A função generateReport() se encarrega de destruir e recriar com novos dados.
      if (!charts.problemTypeChart) renderProblemTypeChart();
      if (!charts.resolutionTimeChart) renderResolutionTimeChart();
    }

    // Renderizar gráfico de tipos de problemas (exemplo ou dados reais)
    function renderProblemTypeChart(problemData = null) {
      const canvas = document.getElementById('problem-type-chart');
      if (!canvas) { console.error("Canvas 'problem-type-chart' não encontrado."); return; }
      const ctx = canvas.getContext('2d');

      // Destruir instância anterior
      if (charts.problemTypeChart) {
           charts.problemTypeChart.destroy();
           charts.problemTypeChart = null;
       }

       const dataToUse = (problemData && Object.keys(problemData).length > 0) ? problemData : null; // Usa dados reais só se não forem vazios

        if (!dataToUse) {
            // Mostrar mensagem de "sem dados" ou "gere um relatório"
             canvas.parentElement.innerHTML = '<p style="text-align:center; padding: 30px; color: var(--text-light);">Selecione um período e clique em "Gerar Relatório" para ver a análise de problemas.</p><canvas id="problem-type-chart" style="display:none;"></canvas>'; // Esconde canvas
            return;
        }

        // Garantir que o canvas exista após limpar o container
        if (!document.getElementById('problem-type-chart')) {
            // Se o elemento pai foi limpo, recria o canvas dentro dele
            const container = document.getElementById('tab-reports').querySelector('.section:nth-child(2) .chart-container'); // Encontra o container
            if (container) {
                container.innerHTML = '<canvas id="problem-type-chart"></canvas>';
            } else {
                console.error("Container do gráfico de problemas não encontrado para recriar canvas.");
                return;
            }
        }
        const finalCanvas = document.getElementById('problem-type-chart');
        const finalCtx = finalCanvas.getContext('2d');


       const labels = Object.keys(dataToUse);
       const values = Object.values(dataToUse);
       // Usar cores diferentes para cada barra
        const barColors = ['#0d6efd', '#6f42c1', '#fd7e14', '#20c997', '#dc3545', '#ffc107', '#6c757d', '#17a2b8'];
        const backgroundColors = labels.map((_, index) => barColors[index % barColors.length]);


      charts.problemTypeChart = new Chart(finalCtx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{ label: 'Ocorrências', data: values, backgroundColor: backgroundColors }]
        },
        options: {
             responsive: true,
             maintainAspectRatio: false,
             scales: {
                 y: { beginAtZero: true, title: { display: true, text: 'Nº de Ocorrências'} },
                 x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 0 } } // Evita pular labels, rotaciona se necessário
             },
             plugins: {
                 legend: { display: false },
                 title: { display: true, text: 'Problemas por Categoria (Período Selecionado)'}
            }
        }
      });
    }

    // Renderizar gráfico de tempo de resolução (exemplo ou dados reais)
    function renderResolutionTimeChart(timeData = null) {
      const canvas = document.getElementById('resolution-time-chart');
      if (!canvas) { console.error("Canvas 'resolution-time-chart' não encontrado."); return;}
      const ctx = canvas.getContext('2d');

      // Destruir instância anterior
      if (charts.resolutionTimeChart) {
           charts.resolutionTimeChart.destroy();
           charts.resolutionTimeChart = null;
      }


       // Usar dados recebidos ou mostrar mensagem
       const dataToUse = (timeData && Object.keys(timeData).length > 0) ? timeData : null;

        if (!dataToUse) {
             canvas.parentElement.innerHTML = '<p style="text-align:center; padding: 30px; color: var(--text-light);">Selecione um período e clique em "Gerar Relatório" para ver o tempo de resolução.</p><canvas id="resolution-time-chart" style="display:none;"></canvas>'; // Esconde canvas
            return;
        }

        // Garantir que o canvas exista
         if (!document.getElementById('resolution-time-chart')) {
             // Se o elemento pai foi limpo, recria o canvas dentro dele
             const container = document.getElementById('tab-reports').querySelector('.section:nth-child(3) .chart-container'); // Encontra o container
             if(container){
                container.innerHTML = '<canvas id="resolution-time-chart"></canvas>';
             } else {
                 console.error("Container do gráfico de tempo não encontrado para recriar canvas.");
                 return;
             }
         }
         const finalCanvas = document.getElementById('resolution-time-chart');
         const finalCtx = finalCanvas.getContext('2d');

      const labels = Object.keys(dataToUse); // Ex: ['Jan', 'Fev', 'Mar'] ou ['Semana 1', 'Semana 2']
      const dataValues = Object.values(dataToUse); // Ex: [2.5, 3.1, 1.9] (dias)


      charts.resolutionTimeChart = new Chart(finalCtx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
              label: 'Tempo Médio (dias)',
              data: dataValues,
              borderColor: '#28a745',
              backgroundColor: 'rgba(40, 167, 69, 0.1)', // Área preenchida opcional
              tension: 0.1,
              fill: true // Preencher área abaixo da linha
           }]
        },
         options: {
             responsive: true,
             maintainAspectRatio: false,
             scales: {
                 y: { beginAtZero: true, title: { display: true, text: 'Dias' } },
                 x: { title: { display: true, text: 'Período' } } // Adiciona label ao eixo X
             },
             plugins: {
                 legend: { display: true, position: 'top' }, // Mostra legenda
                 title: { display: true, text: 'Tempo Médio de Resolução (Período Selecionado)' }
            }
         }
      });
    }

    // Abrir formulário de manutenção
    function openMaintenanceForm() {
      resetMaintenanceForm(); // Garante que está limpo
      document.getElementById('maintenance-form-overlay').style.display = 'block';
      goToFormStep('maintenance', 1); // Sempre começa na etapa 1
    }

    // Fechar formulário de manutenção
    function closeMaintenanceForm() {
      document.getElementById('maintenance-form-overlay').style.display = 'none';
      stopAllCameraStreams(); // Garante que a câmera seja liberada
      resetMaintenanceForm(); // Limpa os dados do formulário
    }

    // Resetar formulário de manutenção
    function resetMaintenanceForm() {
      const form = document.getElementById('maintenance-form');
      if (form) form.reset(); // Reseta campos padrão
      capturedImages = []; // Limpar array de imagens
      const gallery = document.getElementById('image-gallery');
       if(gallery) gallery.innerHTML = ''; // Limpar galeria visual
      const warning = document.getElementById('photo-warning');
       if(warning) warning.style.display = 'none'; // Esconder aviso

      // Resetar campos de formulário que não são resetados por form.reset() (ex: data padrão)
       const today = new Date();
       const dateInput = document.getElementById('maintenance-date');
       if (dateInput) {
           try { dateInput.valueAsDate = today; } catch(e) { dateInput.value = today.toISOString().split('T')[0];}
       }

       // Resetar bordas de erro
        if (form) {
            form.querySelectorAll('.form-control.is-invalid').forEach(el => el.classList.remove('is-invalid'));
            // Ou se usou style.borderColor
            form.querySelectorAll('input[style*="border-color: red"], select[style*="border-color: red"], textarea[style*="border-color: red"]').forEach(el => el.style.borderColor = '');
        }


      // Resetar visualização da câmera e galeria
      stopCameraStream(); // Tenta parar stream principal
      const video = document.getElementById('camera-stream');
      const capturedImg = document.getElementById('captured-image');
      const placeholder = document.getElementById('camera-placeholder');
      const takeBtn = document.getElementById('take-photo');

       if(video) video.style.display = 'none';
       if(capturedImg) { capturedImg.style.display = 'none'; capturedImg.src = ''; }
       if(placeholder) placeholder.style.display = 'flex';
       if(takeBtn) takeBtn.disabled = true;

       // Voltar para a etapa 1 visualmente
       goToFormStep('maintenance', 1);
    }

    // Abrir formulário de verificação
    function openVerificationForm(maintenanceId) {
       if (!maintenanceId) {
            showNotification("ID da manutenção inválido para verificação.", "error");
            return;
       }
      resetVerificationForm(); // Garante que está limpo
      selectedMaintenanceId = maintenanceId; // Guardar ID para submissão

      const maintenance = maintenanceList.find(m => m.id === maintenanceId);
      if (maintenance) {
        // Preencher campos informativos (não editáveis)
        document.getElementById('verification-id').value = maintenance.id;
        document.getElementById('verification-equipment').value = maintenance.equipmentId || '-';
        document.getElementById('verification-type').value = maintenance.maintenanceType || maintenance.type || '-';
        // Abrir o overlay
        document.getElementById('verification-form-overlay').style.display = 'block';
      } else {
         showNotification(`Manutenção com ID ${maintenanceId} não encontrada. Recarregue a lista.`, 'error');
         selectedMaintenanceId = null; // Limpa ID se não encontrou
      }
    }

    // Fechar formulário de verificação
    function closeVerificationForm() {
      document.getElementById('verification-form-overlay').style.display = 'none';
      stopAllCameraStreams(); // Garante que a câmera seja liberada
      resetVerificationForm(); // Limpa os dados
    }

    // Resetar formulário de verificação
    function resetVerificationForm() {
      const form = document.getElementById('verification-form');
      if (form) form.reset();
      verificationImages = []; // Limpar array
      const gallery = document.getElementById('verification-image-gallery');
       if(gallery) gallery.innerHTML = ''; // Limpar galeria visual
      selectedMaintenanceId = null; // Limpar ID selecionado

      // Resetar bordas de erro
       if (form) {
            form.querySelectorAll('.form-control.is-invalid').forEach(el => el.classList.remove('is-invalid'));
            form.querySelectorAll('input[style*="border-color: red"], select[style*="border-color: red"], textarea[style*="border-color: red"]').forEach(el => el.style.borderColor = '');
             // Resetar cor do label do radio
             const radioGroupLabel = document.querySelector('#verification-form label[for="verification-approved"]')?.parentElement.querySelector('label');
             if(radioGroupLabel) radioGroupLabel.style.color = '';
       }


      // Resetar visualização da câmera e galeria
       stopVerificationCameraStream();
      const video = document.getElementById('verification-camera-stream');
      const capturedImg = document.getElementById('verification-captured-image');
      const placeholder = document.getElementById('verification-camera-placeholder');
      const takeBtn = document.getElementById('verification-take-photo');

       if(video) video.style.display = 'none';
       if(capturedImg) { capturedImg.style.display = 'none'; capturedImg.src = ''; }
       if(placeholder) placeholder.style.display = 'flex';
       if(takeBtn) takeBtn.disabled = true;
    }

    // Navegar para uma etapa do formulário (Manutenção)
    function goToFormStep(formType, step) {
        // Implementado apenas para manutenção
        if (formType !== 'maintenance') return;

        const formId = 'maintenance-form';
        const stepContentPrefix = 'step-'; // ID base do conteúdo da etapa
        const stepIndicatorSelector = `.form-step`; // Classe dos indicadores visuais (simplificado)

        console.log(`Navegando para Etapa ${step} do formulário ${formType}`);

        // Ocultar todos os conteúdos de etapa
        document.querySelectorAll(`#${formId} .form-step-content`).forEach(content => {
            content.style.display = 'none';
        });

        // Atualizar indicadores visuais de etapa (bolinhas numeradas)
        document.querySelectorAll(`#maintenance-form-overlay ${stepIndicatorSelector}`).forEach(stepEl => {
            const stepNum = parseInt(stepEl.getAttribute('data-step'));
            stepEl.classList.remove('active', 'completed');
            if (stepNum === step) {
                stepEl.classList.add('active');
            } else if (stepNum < step) {
                stepEl.classList.add('completed');
            }
        });

        // Mostrar o conteúdo da etapa atual
        const contentId = `${stepContentPrefix}${step}-content`;
        const stepContentElement = document.getElementById(contentId);
        if (stepContentElement) {
            stepContentElement.style.display = 'block';
             // Focar no primeiro campo da etapa (melhora usabilidade)
             const firstInput = stepContentElement.querySelector('input:not([type=hidden]):not([type=button]):not([type=submit]):not([type=reset]):not([disabled]), select:not([disabled]), textarea:not([disabled])');
             if (firstInput) {
                 // Usar setTimeout para garantir que o elemento esteja visível antes de focar
                 setTimeout(() => firstInput.focus(), 50);
             }
        } else {
            console.error(`Elemento de conteúdo da etapa ${contentId} não encontrado.`);
        }

        // Parar a câmera se saindo da etapa 3 (precaução)
        if (step !== 3) {
           stopCameraStream(); // Para a câmera principal do form de manutenção
        }
        // Adicionar lógica similar para verificação se tivesse múltiplas etapas com câmera
    }

    // Função melhorada para abrir a câmera
    function openCamera(videoId, placeholderId) {
      const video = document.getElementById(videoId);
      const placeholder = document.getElementById(placeholderId);
      // Determina o botão correspondente
      const takePhotoBtnId = videoId === 'camera-stream' ? 'take-photo' : 'verification-take-photo';
      const takePhotoBtn = document.getElementById(takePhotoBtnId);

       // Verifica se os elementos existem
       if (!video || !placeholder || !takePhotoBtn) {
           console.error("Elementos da câmera não encontrados:", videoId, placeholderId, takePhotoBtnId);
           showNotification("Erro interno: Elementos da câmera não encontrados.", "error");
           return;
       }

      console.log("Tentando abrir câmera para " + videoId);

      // Certificar-se de fechar o stream específico ANTES de tentar abrir um novo
       if (videoId === 'camera-stream') {
           stopCameraStream();
       } else {
           stopVerificationCameraStream();
       }


      // Verificar se o navegador suporta getUserMedia
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showNotification('Seu navegador não suporta acesso à câmera.', 'error');
        placeholder.textContent = "Câmera não suportada."; // Atualiza placeholder
        placeholder.style.display = 'flex';
        video.style.display = 'none';
        takePhotoBtn.disabled = true;
        return;
      }

      // Mostrar mensagem de carregando no placeholder
      placeholder.textContent = "Abrindo câmera...";
      placeholder.style.display = 'flex';
      video.style.display = 'none';
      takePhotoBtn.disabled = true;


      // Adicionar um pequeno delay antes de solicitar a câmera novamente (opcional)
      // setTimeout(() => {
        console.log("Solicitando acesso à câmera para " + videoId + "...");

        // Solicitar acesso à câmera (preferência pela traseira 'environment')
         // Adicionar constraints para tentar melhorar qualidade/resolução se possível
        const constraints = {
             video: {
                 facingMode: 'environment', // Prioriza câmera traseira
                 width: { ideal: 1280, max: 1920 }, // Tenta HD, máximo Full HD
                 height: { ideal: 720, max: 1080 },
                 // frameRate: { ideal: 15 } // Reduzir framerate pode economizar bateria/processamento
             },
             audio: false // Não precisa de áudio
         };


        navigator.mediaDevices.getUserMedia(constraints)
        .then(stream => {
           console.log("Stream da câmera obtido para " + videoId);
          // Guardar referência ao stream correto
          if (videoId === 'camera-stream') {
            cameraStream = stream;
          } else {
            verificationCameraStream = stream;
          }

          // Exibir vídeo
          video.srcObject = stream;
          video.style.display = 'block'; // Mostra o vídeo
          placeholder.style.display = 'none'; // Esconde o placeholder

          // Habilitar botão após o carregamento completo do vídeo
          video.onloadedmetadata = function() {
            console.log("Metadados do vídeo " + videoId + " carregados, botão habilitado.");
            takePhotoBtn.disabled = false;
          };
          // Handle para caso o stream termine inesperadamente
          stream.getVideoTracks()[0].onended = () => {
             console.warn(`Stream da câmera ${videoId} terminou inesperadamente.`);
             showNotification("A conexão com a câmera foi interrompida.", "warning");
             stopAllCameraStreams(); // Tenta limpar tudo
          };

        })
        .catch(error => {
          console.error("Erro ao acessar câmera " + videoId + ":", error.name, error.message);

          // Mensagem de erro mais específica
          let userMessage = 'Erro desconhecido ao acessar câmera.';
          if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
             userMessage = 'Erro: Não foi possível ler da câmera. Pode estar em uso por outro app ou houve um erro no hardware.';
          } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
             userMessage = 'Permissão para acessar câmera negada. Verifique as configurações do navegador/site.';
          } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
             userMessage = 'Nenhuma câmera compatível encontrada.';
          } else if (error.name === 'AbortError') {
              userMessage = 'Acesso à câmera abortado.'; // Pode acontecer se o usuário interagir rapidamente
          } else if (error.name === 'OverconstrainedError') {
               userMessage = 'A câmera não suporta as configurações solicitadas (resolução, etc.). Tentando configuração padrão...';
               console.warn("OverconstrainedError - tentando sem constraints específicas...");
               // Tentar novamente com constraints mais simples (sem especificar resolução)
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment'}, audio: false })
                    .then(stream => { // Copia da lógica de sucesso
                        console.log("Stream da câmera (fallback) obtido para " + videoId);
                        if (videoId === 'camera-stream') cameraStream = stream;
                        else verificationCameraStream = stream;
                        video.srcObject = stream;
                        video.style.display = 'block';
                        placeholder.style.display = 'none';
                        video.onloadedmetadata = () => { takePhotoBtn.disabled = false; };
                        stream.getVideoTracks()[0].onended = () => { console.warn(`Stream (fallback) ${videoId} ended.`); stopAllCameraStreams(); };
                     })
                    .catch(fallbackError => { // Lógica de erro final
                        console.error("Erro ao acessar câmera (fallback):", fallbackError.name, fallbackError.message);
                        let finalMessage = `Falha ao abrir câmera: ${fallbackError.name}`;
                         if (fallbackError.name === 'NotAllowedError' || fallbackError.name === 'PermissionDeniedError') {
                             finalMessage = 'Permissão para acessar câmera negada. Verifique as configurações do navegador/site.';
                         } else if (fallbackError.name === 'NotFoundError' || fallbackError.name === 'DevicesNotFoundError') {
                             finalMessage = 'Nenhuma câmera compatível encontrada.';
                         }
                        showNotification(finalMessage, 'error');
                        takePhotoBtn.disabled = true;
                        video.style.display = 'none'; video.srcObject = null;
                        placeholder.textContent = "Falha ao abrir câmera."; placeholder.style.display = 'flex';
                    });
                return; // Sai da execução atual, a nova tentativa tratará o resultado
          } else {
              userMessage = `Erro ao acessar câmera: ${error.name}`;
          }

          showNotification(userMessage, 'error');
          // Garantir que o botão de foto permaneça desabilitado e placeholder visível com msg de erro
           takePhotoBtn.disabled = true;
           video.style.display = 'none';
           video.srcObject = null; // Limpa stream se algum foi atribuído parcialmente
           placeholder.textContent = "Falha ao abrir câmera.";
           placeholder.style.display = 'flex';
        });
      // }, 100); // Fim do delay opcional
    }

    // Função melhorada para parar stream da câmera principal
    function stopCameraStream() {
      if (cameraStream) {
        console.log("Parando stream principal da câmera...");
        let stoppedTracks = 0;
        cameraStream.getTracks().forEach(track => {
          if (track.readyState === 'live') {
            track.stop();
            stoppedTracks++;
            console.log(`Track ${track.kind} (${track.id}) parada.`);
          }
        });
        cameraStream = null;
         if (stoppedTracks > 0) console.log("Stream principal parado.");

         // Resetar visualização associada
        const video = document.getElementById('camera-stream');
        const btn = document.getElementById('take-photo');
        const placeholder = document.getElementById('camera-placeholder');
        if(video) { video.srcObject = null; video.style.display = 'none'; }
        if(btn) btn.disabled = true;
         if(placeholder) {
             placeholder.textContent = 'Clique em "Abrir Câmera" para capturar imagens'; // Reset text
             placeholder.style.display = 'flex';
         }
      }
    }

    // Função melhorada para parar stream da câmera de verificação
    function stopVerificationCameraStream() {
      if (verificationCameraStream) {
        console.log("Parando stream da câmera de verificação...");
         let stoppedTracks = 0;
        verificationCameraStream.getTracks().forEach(track => {
          if (track.readyState === 'live') {
             track.stop();
             stoppedTracks++;
             console.log(`Track ${track.kind} (${track.id}) parada.`);
          }
        });
        verificationCameraStream = null;
         if (stoppedTracks > 0) console.log("Stream de verificação parado.");

         // Resetar visualização associada
        const video = document.getElementById('verification-camera-stream');
        const btn = document.getElementById('verification-take-photo');
        const placeholder = document.getElementById('verification-camera-placeholder');
         if(video) { video.srcObject = null; video.style.display = 'none'; }
        if(btn) btn.disabled = true;
        if(placeholder) {
             placeholder.textContent = 'Clique em "Abrir Câmera" para capturar imagens'; // Reset text
             placeholder.style.display = 'flex';
         }
      }
    }

    // Função melhorada para parar todos os streams conhecidos
    function stopAllCameraStreams() {
      console.log("Parando todos os streams de câmera...");
      stopCameraStream();
      stopVerificationCameraStream();

      // Adicional: verificar se algum vídeo ainda tem stream ativo (precaução)
      document.querySelectorAll('video').forEach(video => {
         if (video.srcObject) {
              let stream = video.srcObject;
              if (stream && typeof stream.getTracks === 'function') {
                   console.warn(`Encontrado stream residual no vídeo ${video.id}. Tentando parar...`);
                   stream.getTracks().forEach(track => {
                        if(track.readyState === 'live') track.stop();
                   });
                   video.srcObject = null; // Limpa referência
              }
         }
          // Reset visual state if needed
          const placeholderId = video.id.replace('-stream', '-placeholder');
          const placeholder = document.getElementById(placeholderId);
          if (placeholder && placeholder.style.display === 'none') {
               video.style.display = 'none';
               placeholder.textContent = 'Clique em "Abrir Câmera" para capturar imagens';
               placeholder.style.display = 'flex';
          }
          const btnId = video.id.replace('-stream', '-take-photo');
          const btn = document.getElementById(btnId);
          if (btn) btn.disabled = true;
      });
    }

    // Função melhorada para tirar foto
    function takePhoto(videoId, imgId) { // imgId não é mais usado para preview, mas para identificar galeria
      const video = document.getElementById(videoId);
      // Determina qual array e qual galeria usar
      const isMaintenanceForm = (videoId === 'camera-stream');
      const galleryId = isMaintenanceForm ? 'image-gallery' : 'verification-image-gallery';


      // Verificar se o vídeo está ativo e pronto
      if (!video || video.style.display !== 'block' || !video.srcObject || video.readyState < video.HAVE_METADATA || video.videoWidth === 0 || video.videoHeight === 0) {
        showNotification('A câmera não está ativa ou pronta. Tente abri-la novamente.', 'error');
         console.warn("Tentativa de tirar foto com vídeo inativo/não pronto:", videoId);
        return;
      }

      console.log(`Capturando foto de ${videoId}... Dimensões: ${video.videoWidth}x${video.videoHeight}`);

      // Criar canvas para capturar imagem
      const canvas = document.createElement('canvas');
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx = canvas.getContext('2d');

      try {
          // Desenhar frame do vídeo no canvas
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

          // Converter para base64 JPEG com qualidade (0.85 = 85%, bom equilíbrio)
          let dataUrl = canvas.toDataURL('image/jpeg', 0.85);

          // Verificar se o dataUrl é válido
          if (!dataUrl || dataUrl === 'data:,') {
            throw new Error("DataURL inválido gerado pelo canvas.");
          }

          console.log(`Foto capturada (${(dataUrl.length / 1024).toFixed(1)} KB), adicionando à galeria ${galleryId}`);

          // Adicionar à galeria apropriada
          addImageToGallery(dataUrl, galleryId);

          // Parar o stream APÓS tirar a foto para liberar a câmera
          if (isMaintenanceForm) {
              stopCameraStream();
          } else {
              stopVerificationCameraStream();
          }

      } catch (error) {
           console.error("Erro ao capturar ou processar foto:", error);
           showNotification(`Erro ao capturar foto: ${error.message}. Tente novamente.`, 'error');
           // Tentar parar a câmera mesmo em caso de erro
            if (isMaintenanceForm) stopCameraStream(); else stopVerificationCameraStream();
           return;
      }
    }

    // Função melhorada para adicionar imagem à galeria (usada por takePhoto e handleFileUpload)
    function addImageToGallery(dataUrl, galleryId) {
        const gallery = document.getElementById(galleryId);
        if (!gallery) {
            console.error(`Elemento da galeria #${galleryId} não encontrado.`);
            return;
        }

        // Determina o array correto para adicionar a imagem
        const imageArray = galleryId === 'image-gallery' ? capturedImages : verificationImages;

        // Adiciona ao array de dados PRIMEIRO
        imageArray.push(dataUrl);
        const imageIndex = imageArray.length - 1; // Índice da imagem no array
        console.log(`Imagem adicionada ao array ${galleryId} (índice ${imageIndex}). Total: ${imageArray.length}.`);


        // Criar elemento visual na galeria
        const imgContainer = document.createElement('div');
        imgContainer.className = 'image-item';
        imgContainer.setAttribute('data-index', imageIndex); // Guarda o índice para remoção

        const img = document.createElement('img');
         // Adiciona tratamento de erro para carregamento da imagem na galeria
         img.onerror = () => {
             console.error(`Erro ao carregar preview da imagem ${imageIndex} na galeria.`);
             img.alt = 'Erro ao carregar';
             imgContainer.style.border = '1px solid var(--danger-color)'; // Indica erro visual
         };
        img.src = dataUrl;
        img.alt = `Imagem ${imageIndex + 1}`;


        const removeBtn = document.createElement('div');
        removeBtn.className = 'image-remove';
        removeBtn.innerHTML = '&times;';
        removeBtn.title = 'Remover imagem';
        removeBtn.onclick = function(e) { // Usar onclick para simplicidade aqui
            e.stopPropagation(); // Impedir disparo do clique no container

            const containerToRemove = this.closest('.image-item');
            const indexToRemove = parseInt(containerToRemove.getAttribute('data-index'));

            console.log(`Tentando remover imagem índice ${indexToRemove} da galeria ${galleryId}`);

             // Remover do array de dados usando o índice guardado
             if (indexToRemove >= 0 && indexToRemove < imageArray.length && imageArray[indexToRemove]) {
                 // Marcar como null ou undefined em vez de splice para não bagunçar índices de outros elementos visuais
                 // Se precisar realmente remover (ex: antes de submit), use splice e atualize índices.
                 // Marcando como null para a lógica de remoção visual simples.
                 imageArray[indexToRemove] = null; // Marca como removida no array
                 console.log(`Imagem índice ${indexToRemove} marcada como removida no array ${galleryId}.`);
             } else {
                 console.warn(`Índice ${indexToRemove} inválido ou imagem já removida do array ${galleryId}.`);
             }


            // Remove o elemento visual
            containerToRemove.remove();

            // Atualiza contagem visual ou aviso se necessário
            const remainingImages = imageArray.filter(imgData => imgData !== null).length; // Conta as não nulas
             console.log(`Galeria ${galleryId} agora tem ${remainingImages} imagens visíveis.`);

            // Mostrar aviso se a galeria principal (manutenção) ficar vazia
            if (galleryId === 'image-gallery') {
                const photoWarning = document.getElementById('photo-warning');
                if (photoWarning) {
                    photoWarning.style.display = remainingImages === 0 ? 'block' : 'none';
                }
            }
        };

        // Adicionar evento para visualizar em tamanho maior ao clicar no container
        imgContainer.onclick = function() { // Usar onclick
            const indexToView = parseInt(this.getAttribute('data-index'));
            // Busca a imagem no array original (pode ter sido removida - null)
             if (indexToView >= 0 && indexToView < imageArray.length && imageArray[indexToView]) {
                 openImageModal(imageArray[indexToView]);
             } else {
                 console.warn(`Imagem índice ${indexToView} não encontrada ou removida para visualização.`);
                 // Opcional: Remover o elemento visual se não encontrar no array
                 // this.remove();
             }
        };

        imgContainer.appendChild(img);
        imgContainer.appendChild(removeBtn);
        gallery.appendChild(imgContainer);

        // Se for o formulário principal, esconder aviso de foto obrigatória
        if (galleryId === 'image-gallery') {
            const photoWarning = document.getElementById('photo-warning');
            if (photoWarning) {
                photoWarning.style.display = 'none';
            }
        }
    }


    // Função handleFileUpload corrigida e melhorada
    function handleFileUpload(event, imgId) { // imgId usado para determinar galeria
      try {
        const file = event.target.files[0];
        if (!file) {
            console.log("Nenhum arquivo selecionado.");
            return;
        }

        // Verificar se é uma imagem
        if (!file.type.startsWith('image/')) {
          showNotification('Arquivo inválido. Por favor, selecione um arquivo de imagem (JPG, PNG, GIF, etc.).', 'error');
           event.target.value = null; // Limpa seleção
          return;
        }

         // Verificar tamanho do arquivo (ex: limite de 5MB)
         const maxSizeMB = 5;
         if (file.size > maxSizeMB * 1024 * 1024) {
              showNotification(`Arquivo muito grande (${(file.size / 1024 / 1024).toFixed(1)} MB). O limite é ${maxSizeMB} MB.`, 'error');
              event.target.value = null; // Limpa seleção
              return;
         }

        // Determina a galeria correta
        const galleryId = imgId === 'captured-image' ? 'image-gallery' : 'verification-image-gallery';

        // Mostrar loading enquanto lê o arquivo? (Opcional)
        // showLoading(true, 'Carregando imagem...');

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const dataUrl = e.target.result;
            if (!dataUrl) {
                throw new Error("FileReader não retornou resultado.");
            }

             console.log(`Arquivo ${file.name} lido com sucesso (${(dataUrl.length/1024).toFixed(1)} KB), adicionando à galeria ${galleryId}`);

            // Adicionar diretamente à galeria correta
            addImageToGallery(dataUrl, galleryId);

          } catch (error) {
            console.error("Erro ao processar imagem carregada:", error);
            showNotification('Erro ao processar imagem: ' + error.message, 'error');
          } finally {
             // showLoading(false); // Esconder loading se mostrou
          }
        };

        reader.onerror = function(error) {
          console.error("Erro ao ler arquivo:", error);
          showNotification('Erro ao ler arquivo: ' + error.message, 'error');
           // showLoading(false); // Esconder loading
        };

        reader.readAsDataURL(file); // Inicia a leitura

      } catch (error) {
        console.error("Erro em handleFileUpload:", error);
        showNotification('Erro inesperado ao processar upload: ' + error.message, 'error');
      } finally {
          // Resetar o input de arquivo para permitir selecionar o mesmo arquivo novamente
          event.target.value = null;
      }
    }

    // Submeter formulário de verificação
    function submitVerification() {
        // Garantir que temos um ID selecionado
        if (!selectedMaintenanceId) {
            showNotification("Erro: ID da manutenção a ser verificada não foi encontrado.", "error");
            return;
        }

        // Validação dos campos obrigatórios já feita pelo listener de submit
        const formDataRaw = {
            maintenanceId: selectedMaintenanceId,
            verifier: document.getElementById('verifier-name').value.trim(),
            result: document.querySelector('input[name="verification-result"]:checked')?.value, // Usa optional chaining
            comments: document.getElementById('verification-comments').value.trim(),
            images: verificationImages.filter(img => img !== null) // Filtra imagens removidas (marcadas como null)
        };

        // Re-validar aqui para garantir
        if (!formDataRaw.verifier || !formDataRaw.result || !formDataRaw.comments) {
            showNotification("Erro: Preencha todos os campos obrigatórios da verificação.", "error");
             validateFormStep('verification'); // Mostra quais campos faltam
            return;
        }


        showLoading(true, 'Salvando verificação...');

        // Comprimir imagens da verificação ANTES de enviar
        console.log(`Iniciando compressão de ${formDataRaw.images.length} imagens de verificação...`);
        const compressPromises = formDataRaw.images.map((image, index) => {
            console.log(`Comprimindo imagem de verificação ${index+1}...`);
            // Usar compressão definida (500px, 0.7 quality)
            return compressImage(image, 500, 0.7)
             .catch(error => {
                console.error(`Erro ao comprimir imagem de verificação ${index + 1}:`, error);
                showNotification(`Erro ao comprimir imagem ${index + 1}. A original será usada.`, 'warning');
                return image; // Retorna a original em caso de erro
             });
        });

        Promise.all(compressPromises)
         .then(compressedVerificationImages => {
            console.log(`${compressedVerificationImages.length} imagens de verificação prontas para envio.`);

            const finalFormData = {
                ...formDataRaw,
                images: compressedVerificationImages // Atualiza com as imagens processadas
            };

             // Verificar tamanho antes de chamar API (callAPI original JSONP tem limites)
             let jsonSize;
             try {
                jsonSize = JSON.stringify(finalFormData).length;
                console.log("Tamanho estimado dos dados de verificação:", (jsonSize / 1024 / 1024).toFixed(2), "MB");
                 if (jsonSize > 1800000) { // Limite JSONP GET payload (conservador)
                     throw new Error("Dados da verificação (incluindo fotos) são muito grandes (> ~1.8MB). Tente com menos fotos ou fotos menores.");
                 }
             } catch (e) {
                  showLoading(false);
                  console.error("Erro ao processar/verificar tamanho dos dados:", e);
                  showNotification(e.message || "Erro ao preparar dados da verificação.", "error");
                  return Promise.reject(e); // Rejeita a promessa para não continuar
             }

            showLoading(true, 'Enviando dados da verificação...');
            console.log("Enviando verificação (via callAPI JSONP)...");
            // IMPORTANTE: callAPI pode falhar aqui se o payload for grande.
            // Se necessário, implementar upload direto para Drive para fotos de verificação também.
            return callAPI('saveVerification', finalFormData);
        })
        .then(result => {
            // Este .then() é da callAPI
            showLoading(false);
            if (result && result.success) {
                showNotification('Verificação registrada com sucesso!', 'success');
                closeVerificationForm();
                loadDashboardData(); // Recarrega tudo para refletir a mudança de status
                loadMaintenanceDataIfNeeded(true); // Força recarga da lista tbm
            } else {
                // Erro retornado pela API
                console.error("Erro retornado pela API saveVerification:", result);
                showNotification('Erro ao registrar verificação: ' + (result ? result.message : 'Erro desconhecido'), 'error');
            }
        })
        .catch(error => {
            // Captura erros da compressão, verificação de tamanho, ou da callAPI/JSONP
            console.error("Erro GERAL no processo de submissão da verificação:", error);
            showLoading(false);
             let userMessage = 'Ocorreu um erro inesperado ao salvar a verificação.';
             if (error.message && (error.message.includes("muito grandes") || error.message.includes("Payload de dados muito grande"))) {
                userMessage = "Erro: Os dados da verificação (fotos) são muito grandes. Tente com menos fotos.";
             } else if (error.message && (error.message.includes("Falha na comunicação") || error.message.includes("API (JSONP)"))) {
                userMessage = "Erro de comunicação com o servidor ao salvar verificação. Verifique sua conexão.";
             } else if (error.message && error.message.includes("Timeout")) {
                userMessage = "O servidor demorou muito para responder. Verificação não salva.";
             } else {
                userMessage = 'Erro ao salvar verificação: ' + error.message;
             }
            showNotification(userMessage, 'error');
        });
    }


    // Ver detalhes de uma manutenção
    function viewMaintenanceDetails(maintenanceId) {
       if (!maintenanceId) {
            showNotification("ID de manutenção inválido.", "error");
            return;
       }
       showLoading(true, `Carregando detalhes da manutenção ${maintenanceId}...`);
       selectedMaintenanceId = maintenanceId; // Armazena o ID atual para botão "Verificar"

      callAPI('getMaintenanceDetails', { id: maintenanceId }) // Usa callAPI original JSONP
        .then(details => {
          if (!details || details.error) {
            console.error("Erro ao carregar detalhes:", details);
            showNotification('Erro ao carregar detalhes: ' + (details ? details.message : 'Resposta inválida'), 'error');
             // Limpar conteúdo do modal em caso de erro?
             document.getElementById('maintenance-detail-content').innerHTML = '<p style="color: var(--danger-color); text-align: center;">Não foi possível carregar os detalhes.</p>';
             document.getElementById('detail-overlay').style.display = 'block'; // Mostra overlay com erro
             document.getElementById('verify-maintenance-btn').style.display = 'none'; // Esconde botão verificar
            return;
          }
          console.log("Detalhes recebidos:", details);
          renderMaintenanceDetails(details); // Renderiza os detalhes no modal
          document.getElementById('detail-overlay').style.display = 'block'; // Mostra o modal preenchido

          // Habilitar/desabilitar botão de verificação com base no status dos detalhes recebidos
          const verifyBtn = document.getElementById('verify-maintenance-btn');
           const status = details.status || 'Pendente';
           if (status === 'Pendente') {
              verifyBtn.style.display = 'inline-block'; // Ou 'block'
              verifyBtn.disabled = false;
           } else {
              verifyBtn.style.display = 'none';
              verifyBtn.disabled = true;
           }

        })
        .catch(error => {
           console.error("Falha na requisição de detalhes:", error);
          showNotification('Falha ao buscar detalhes: ' + error.message, 'error');
           document.getElementById('maintenance-detail-content').innerHTML = '<p style="color: var(--danger-color); text-align: center;">Falha ao buscar detalhes. Tente novamente.</p>';
           document.getElementById('detail-overlay').style.display = 'block';
           document.getElementById('verify-maintenance-btn').style.display = 'none';
        })
         .finally(() => {
            showLoading(false);
         });
    }

    // Renderizar detalhes da manutenção no modal
    function renderMaintenanceDetails(details) {
      const container = document.getElementById('maintenance-detail-content');
      if (!container) { console.error("Container de detalhes não encontrado."); return; }
      if (!details || typeof details !== 'object') {
        container.innerHTML = '<p>Erro: Dados de detalhe inválidos recebidos.</p>';
        return;
      }

      // --- Sanitize and prepare data ---
      const id = details.id || 'N/A';
      const registrationDate = formatDate(details.registrationDate, true);
      const status = details.status || 'Desconhecido';
      const statusClass = getStatusClass(status);
      const equipmentId = details.equipmentId || '-';
      const equipmentType = details.equipmentType || '-';
      const technician = details.technician || '-';
      const maintenanceDate = formatDate(details.date);
      const location = details.location || '-';
      const maintenanceType = details.maintenanceType || '-';
      const isCritical = details.isCritical ? 'Sim' : 'Não';
      const problemCategory = details.problemCategory || '-';
      // Sanitize potentially long text fields (basic example)
      const problemDescription = sanitizeHTML(details.problemDescription || '-');
      const solutionDescription = sanitizeHTML(details.solutionDescription || '-');
      const partsReplaced = sanitizeHTML(details.partsReplaced || 'Nenhuma');
      const additionalNotes = sanitizeHTML(details.additionalNotes || 'Nenhuma');

      // --- Render Images ---
      const renderImageGallery = (images, altTextPrefix) => {
          if (!Array.isArray(images) || images.length === 0) {
              return `<p style="font-size: 13px; color: var(--text-light);">Nenhuma foto adicionada.</p>`;
          }
          // Filtrar URLs inválidas ou vazias e mapear
          return `<div class="detail-image-gallery">
              ${images
                  .map((img, index) => {
                       // Assume que img é string (URL) ou objeto {url: string}
                       const imgSrc = (typeof img === 'object' && img !== null) ? img.url : img;
                       // Validação básica da URL
                       if (typeof imgSrc !== 'string' || !(imgSrc.startsWith('https://') || imgSrc.startsWith('data:image'))) { // Aceita data URL também
                           console.warn(`URL/Data URL de imagem inválida encontrada:`, imgSrc?.substring(0, 50) + '...');
                           return `<div class="detail-image-item" title="Imagem inválida" style="background:#eee; display:flex; align-items:center; justify-content:center; color:var(--danger-color);">Inválida</div>`; // Placeholder para URL inválida
                       }
                       return `<div class="detail-image-item view-full-image" data-src="${imgSrc}" title="Clique para ampliar">
                                  <img src="${imgSrc}" alt="${altTextPrefix} ${index + 1}" loading="lazy" onerror="this.parentElement.style.border='1px solid var(--danger-color)'; this.alt='Erro ao carregar';">
                               </div>`;
                   })
                  .join('')}
          </div>`;
      };

      const maintenanceImagesHtml = renderImageGallery(details.images, 'Foto manutenção');

      // --- Render Verification Section ---
      let verificationHtml = '<div class="detail-section"><p style="font-style: italic; color: var(--text-light);">Aguardando verificação.</p></div>';
      if (details.verification && typeof details.verification === 'object') {
          const v = details.verification;
          const verifier = v.verifier || '-';
          const verificationDate = formatDate(v.date, true);
          const result = v.result || '-';
          const comments = sanitizeHTML(v.comments || '-');
          const verificationImagesHtml = renderImageGallery(v.images, 'Foto verificação');

          verificationHtml = `
              <div class="detail-section">
                  <div class="detail-section-title">Verificação</div>
                  <div class="detail-grid">
                      <div class="detail-field"><div class="detail-label">Verificador</div><div class="detail-value">${verifier}</div></div>
                      <div class="detail-field"><div class="detail-label">Data Verificação</div><div class="detail-value">${verificationDate}</div></div>
                      <div class="detail-field"><div class="detail-label">Resultado</div><div class="detail-value">${result}</div></div>
                  </div>
                   <div class="detail-field" style="margin-top: 10px;"><div class="detail-label">Comentários</div><div class="detail-value" style="white-space: pre-wrap;">${comments}</div></div>
                   <div class="detail-section-title" style="margin-top: 15px; border-top: 1px dashed var(--border-color); padding-top:10px;">Fotos da Verificação</div>
                   ${verificationImagesHtml}
              </div>`;
      }

      // --- Render Timeline ---
       // Define datas para a timeline, usando fallbacks
       const regDateForTimeline = details.registrationDate || details.date || null;
       const verDateForTimeline = details.verification ? (details.verification.date || null) : null;
       let compDateForTimeline = null;
       if (status === 'Concluído') {
           compDateForTimeline = details.completionDate || verDateForTimeline || regDateForTimeline; // Usa data de conclusão, ou verificação, ou registro
       }

       let timelineHtml = '';
       if (regDateForTimeline) {
           timelineHtml += `
               <div class="timeline-item">
                   <div class="timeline-dot"></div>
                   <div class="timeline-content">
                       <div class="timeline-title"><span>Manutenção Registrada</span><span class="timeline-date">${formatDate(regDateForTimeline, true)}</span></div>
                       <div class="timeline-description">Por: ${technician}</div>
                   </div>
               </div>`;
       }
       if (details.verification && verDateForTimeline) {
            const dotClass = (status === 'Concluído' || status === 'Verificado' || status === 'Aprovado' || status === 'Ajustes' || status === 'Reprovado') ? 'completed' : '';
            const verifierName = details.verification.verifier || '-';
            const verifierResult = details.verification.result || '-';
           timelineHtml += `
               <div class="timeline-item">
                   <div class="timeline-dot ${dotClass}"></div>
                   <div class="timeline-content">
                       <div class="timeline-title"><span>Verificação Realizada</span><span class="timeline-date">${formatDate(verDateForTimeline, true)}</span></div>
                       <div class="timeline-description">Por: ${verifierName} | Resultado: ${verifierResult}</div>
                   </div>
               </div>`;
       }
       if (status === 'Concluído' && compDateForTimeline) {
           timelineHtml += `
               <div class="timeline-item">
                   <div class="timeline-dot completed"></div>
                   <div class="timeline-content">
                       <div class="timeline-title"><span>Manutenção Concluída</span><span class="timeline-date">${formatDate(compDateForTimeline, true)}</span></div>
                       <div class="timeline-description">Processo finalizado.</div>
                   </div>
               </div>`;
       }
       if (timelineHtml === '') {
           timelineHtml = '<p style="color: var(--text-light);">Histórico indisponível.</p>';
       }


      // --- Assemble Final HTML ---
      const finalHtml = `
        <div class="detail-header">
          <div class="detail-header-left">
            <div class="detail-title">Manutenção #${id}</div>
            <div class="detail-subtitle">Registrada em ${registrationDate}</div>
          </div>
          <div class="detail-header-right"><span class="status-badge status-${statusClass}">${status}</span></div>
        </div>

        <div class="detail-section"><div class="detail-section-title">Informações Básicas</div>
          <div class="detail-grid">
            <div class="detail-field"><div class="detail-label">Equipamento</div><div class="detail-value">${equipmentId}</div></div>
            <div class="detail-field"><div class="detail-label">Tipo Equip.</div><div class="detail-value">${equipmentType}</div></div>
            <div class="detail-field"><div class="detail-label">Técnico</div><div class="detail-value">${technician}</div></div>
            <div class="detail-field"><div class="detail-label">Data Manut.</div><div class="detail-value">${maintenanceDate}</div></div>
            <div class="detail-field"><div class="detail-label">Local</div><div class="detail-value">${location}</div></div>
            <div class="detail-field"><div class="detail-label">Tipo Manut.</div><div class="detail-value">${maintenanceType}</div></div>
            <div class="detail-field"><div class="detail-label">Crítica?</div><div class="detail-value">${isCritical}</div></div>
          </div>
        </div>

        <div class="detail-section"><div class="detail-section-title">Problema e Solução</div>
          <div class="detail-grid">
            <div class="detail-field"><div class="detail-label">Categoria</div><div class="detail-value">${problemCategory}</div></div>
          </div>
           <div class="detail-field"><div class="detail-label">Descrição do Problema</div><div class="detail-value" style="white-space: pre-wrap;">${problemDescription}</div></div>
           <div class="detail-field"><div class="detail-label">Descrição da Solução</div><div class="detail-value" style="white-space: pre-wrap;">${solutionDescription}</div></div>
           <div class="detail-field"><div class="detail-label">Peças Substituídas</div><div class="detail-value" style="white-space: pre-wrap;">${partsReplaced}</div></div>
           <div class="detail-field"><div class="detail-label">Observações Adicionais</div><div class="detail-value" style="white-space: pre-wrap;">${additionalNotes}</div></div>
        </div>

        <div class="detail-section"><div class="detail-section-title">Fotos da Manutenção</div>
          ${maintenanceImagesHtml}
        </div>

        ${verificationHtml}

        <div class="detail-section"><div class="detail-section-title">Histórico</div>
          <div class="timeline">${timelineHtml}</div>
        </div>
      `;

      container.innerHTML = finalHtml;

      // Reatribuir listeners para as imagens recém-criadas NO DETALHE (usando delegação)
       const detailGalleries = container.querySelectorAll('.detail-image-gallery');
       if (detailGalleries.length > 0) {
           detailGalleries.forEach(gallery => {
               // Remover listener antigo para evitar duplicação
               gallery.removeEventListener('click', handleDetailImageClick);
               gallery.addEventListener('click', handleDetailImageClick);
           });
       }
    }

     // Handler para clique em imagens dentro do modal de detalhes
     function handleDetailImageClick(event) {
         const target = event.target.closest('.view-full-image');
         if (target) {
             const imgSrc = target.getAttribute('data-src');
             if (imgSrc) {
                 openImageModal(imgSrc);
             } else {
                 console.warn("Imagem clicada no detalhe não possui data-src.");
             }
         }
     }

     // Basic HTML Sanitizer (replace with a robust library like DOMPurify in production)
     function sanitizeHTML(str) {
         if (!str) return str;
         const temp = document.createElement('div');
         temp.textContent = str;
         // Basicamente previne a renderização de HTML, mas não é seguro contra XSS complexos.
         // Mantém quebras de linha transformando-as em <br> (feito pelo white-space: pre-wrap no CSS)
         return temp.innerHTML;
     }

    // Abrir modal de imagem em tela cheia
    function openImageModal(src) {
      if (!src || typeof src !== 'string') {
          console.warn("Tentativa de abrir modal com imagem inválida (src):", src);
           showNotification("Não foi possível abrir a imagem.", "error");
          return;
      }
      const modal = document.getElementById('imageModal');
      const modalImg = document.getElementById('modalImage');
       if (!modal || !modalImg) {
            console.error("Elementos do modal de imagem não encontrados.");
            return;
       }

      // Limpar src antigo para mostrar loading se demorar
      modalImg.src = '';
      // Adicionar um spinner/loading (opcional)
       modalImg.alt = "Carregando imagem..."; // Placeholder enquanto carrega

      modalImg.src = src; // Define a nova imagem
       modal.style.display = 'flex'; // Mostra o modal

       // Resetar alt text quando carregar ou se der erro
       modalImg.onload = () => { modalImg.alt = "Imagem ampliada"; };
       modalImg.onerror = () => {
           modalImg.alt = "Erro ao carregar imagem";
           showNotification("Erro ao carregar imagem ampliada.", "error");
           // Opcional: esconder modal ou mostrar mensagem de erro dentro dele
           // modal.style.display = 'none';
       };
    }

    // Gerar relatório por período
    function generateReport() {
      const startDate = document.getElementById('report-start-date').value;
      const endDate = document.getElementById('report-end-date').value;

      // Validação das datas
      if (!startDate || !endDate) {
        showNotification('Por favor, selecione as datas inicial e final para o relatório.', 'error');
        return;
      }
       const dStart = new Date(startDate + 'T00:00:00'); // Adiciona hora para evitar problemas de fuso
       const dEnd = new Date(endDate + 'T23:59:59'); // Usa fim do dia para incluir data final completa

      if (isNaN(dStart.getTime()) || isNaN(dEnd.getTime())) {
           showNotification('Datas inválidas selecionadas.', 'error');
           return;
      }
      if (dEnd < dStart) {
         showNotification('A data final não pode ser anterior à data inicial.', 'error');
         return;
      }

      console.log(`Gerando relatório para período: ${startDate} a ${endDate}`);
      showLoading(true, 'Gerando relatório...');

      callAPI('generateReport', { startDate, endDate }) // Usa callAPI original JSONP
        .then(data => {
          if (!data || data.error) {
             console.error("Erro ao gerar relatório:", data);
            showNotification('Erro ao gerar relatório: ' + (data ? data.message : 'Resposta inválida'), 'error');
            // Limpar gráficos em caso de erro
             renderProblemTypeChart(null);
             renderResolutionTimeChart(null);
          } else {
            console.log("Dados do relatório recebidos:", data);
            // Atualizar gráficos da aba de relatórios com os dados recebidos
            renderProblemTypeChart(data.problemTypes || {}); // Passa objeto vazio se não vier
            renderResolutionTimeChart(data.resolutionTimes || {}); // Passa objeto vazio se não vier
            showNotification('Relatório gerado com sucesso. Gráficos atualizados.', 'success');
          }
        })
        .catch(error => {
           console.error("Falha na requisição do relatório:", error);
          showNotification('Falha ao gerar relatório: ' + error.message, 'error');
           renderProblemTypeChart(null);
           renderResolutionTimeChart(null);
        })
        .finally(() => showLoading(false));
    }

    // Exportar dados
    function exportData(format) {
      const startDate = document.getElementById('report-start-date').value;
      const endDate = document.getElementById('report-end-date').value;
       // Reutiliza a mesma validação de datas do generateReport
      if (!startDate || !endDate) {
        showNotification('Por favor, selecione o período para exportação.', 'error');
        return;
      }
       const dStart = new Date(startDate + 'T00:00:00');
       const dEnd = new Date(endDate + 'T23:59:59');
       if (isNaN(dStart.getTime()) || isNaN(dEnd.getTime())) {
           showNotification('Datas inválidas selecionadas.', 'error');
           return;
       }
      if (dEnd < dStart) {
         showNotification('A data final não pode ser anterior à data inicial.', 'error');
         return;
      }

      console.log(`Solicitando exportação para ${format} no período: ${startDate} a ${endDate}`);
      showLoading(true, `Preparando exportação (${format.toUpperCase()})...`);

      callAPI('exportData', { startDate, endDate, format }) // Usa callAPI original JSONP
        .then(result => {
          if (!result || result.error) {
             console.error("Erro na exportação:", result);
            showNotification('Erro na exportação: ' + (result ? result.message : 'Resposta inválida'), 'error');
          } else if (result.url) {
             console.log(`Link de download (${format}) recebido:`, result.url);
            showNotification('Arquivo pronto para download. Abrindo link...', 'success');
            // Abrir link em nova aba para iniciar download
            window.open(result.url, '_blank');
          } else {
             console.error("Resposta da API de exportação inválida (sem URL):", result);
             showNotification('Não foi possível gerar o link para download.', 'error');
          }
        })
        .catch(error => {
           console.error("Falha na requisição de exportação:", error);
          showNotification('Falha ao solicitar exportação: ' + error.message, 'error');
        })
        .finally(() => showLoading(false));
    }


    // --- Funções de Filtragem ---

    // Filtrar manutenções para a lista principal e recentes
    function filterMaintenances(maintenances, filter, search) {
       if (!Array.isArray(maintenances)) return []; // Retorna array vazio se entrada for inválida

       const searchLower = search ? search.toLowerCase().trim() : '';
       const filterLower = filter ? filter.toLowerCase() : 'all';

        return maintenances.filter(m => {
             if (!m || typeof m !== 'object') return false; // Ignora itens inválidos na lista

            // 1. Filtrar por Status
            let statusMatch = false;
            const maintenanceStatus = m.status ? m.status.toLowerCase() : 'pendente'; // Assume pendente se não houver status

            switch (filterLower) {
                case 'pending': statusMatch = maintenanceStatus === 'pendente'; break;
                 // Agrupa 'Verificado', 'Aprovado', 'Ajustes' sob o filtro 'verified'
                case 'verified': statusMatch = ['verificado', 'aprovado', 'ajustes'].includes(maintenanceStatus); break;
                case 'completed': statusMatch = ['concluído', 'concluido'].includes(maintenanceStatus); break;
                case 'all': default: statusMatch = true; break; // 'all' ou filtro desconhecido mostra tudo
            }
            if (!statusMatch) return false; // Se não passou no filtro de status, já descarta

            // 2. Filtrar por Termo de Busca (se houver)
            if (searchLower) {
                // Busca em vários campos relevantes (ignora case)
                 const idMatch = m.id?.toString().toLowerCase().includes(searchLower);
                 const equipIdMatch = m.equipmentId?.toLowerCase().includes(searchLower);
                 const techMatch = m.technician?.toLowerCase().includes(searchLower);
                 const typeMatch = (m.maintenanceType || m.type)?.toLowerCase().includes(searchLower); // Verifica ambos os campos de tipo
                 const categoryMatch = m.problemCategory?.toLowerCase().includes(searchLower);
                 const problemDescMatch = m.problemDescription?.toLowerCase().includes(searchLower);
                 const solutionDescMatch = m.solutionDescription?.toLowerCase().includes(searchLower); // Busca na solução também

                return idMatch || equipIdMatch || techMatch || typeMatch || categoryMatch || problemDescMatch || solutionDescMatch;
            }

            // Se passou pelo status e não há busca, inclui
            return true;

        }).sort((a, b) => { // Ordenar por data de registro (mais recente primeiro)
            const dateA = new Date(a?.registrationDate || a?.date || 0);
            const dateB = new Date(b?.registrationDate || b?.date || 0);
             // Tratar datas inválidas colocando-as no final
             if (isNaN(dateA.getTime())) return 1;
             if (isNaN(dateB.getTime())) return -1;
            return dateB - dateA;
        });
    }

    // Filtrar manutenções para a lista de verificação
    function filterVerifications(maintenances, filter, search) {
         if (!Array.isArray(maintenances)) return [];

        const searchLower = search ? search.toLowerCase().trim() : '';
        const filterLower = filter ? filter.toLowerCase() : 'all';
        const todayStr = new Date().toISOString().split('T')[0]; // Formato YYYY-MM-DD para filtro 'hoje'

        return maintenances.filter(m => {
            if (!m || typeof m !== 'object') return false;

             // 1. Filtro primário por status/condição de verificação
             let baseFilterMatch = false;
             const status = m.status ? m.status.toLowerCase() : 'pendente';
             const verificationDate = m.verification?.date; // Pega data da verificação se existir

             switch (filterLower) {
                 case 'pending':
                     baseFilterMatch = (status === 'pendente');
                     break;
                 case 'verified': // Mostra os verificados de HOJE
                      baseFilterMatch = ['verificado', 'aprovado', 'ajustes', 'reprovado'].includes(status) && // Qualquer status pós-pendente
                                       verificationDate && verificationDate.startsWith(todayStr);
                      break;
                 case 'completed': // Mostra os concluídos (status final)
                      baseFilterMatch = ['concluído', 'concluido'].includes(status);
                      break;
                 case 'all': // Mostra todos que precisam ou já passaram por verificação (exceto talvez os muito antigos?)
                 default:
                      // Inclui Pendente, Verificado, Aprovado, Ajustes, Reprovado, Concluído
                      baseFilterMatch = true; // Simplificado: mostra todos por padrão no 'all'
                      break;
             }

             if (!baseFilterMatch) return false;

             // 2. Filtro por termo de busca (se houver) nos campos principais
             if (searchLower) {
                 const idMatch = m.id?.toString().toLowerCase().includes(searchLower);
                 const equipIdMatch = m.equipmentId?.toLowerCase().includes(searchLower);
                 const techMatch = m.technician?.toLowerCase().includes(searchLower);
                 const typeMatch = (m.maintenanceType || m.type)?.toLowerCase().includes(searchLower);
                 // Poderia buscar no nome do verificador também, se relevante
                 const verifierMatch = m.verification?.verifier?.toLowerCase().includes(searchLower);

                 return idMatch || equipIdMatch || techMatch || typeMatch || verifierMatch;
             }

             return true; // Passou nos filtros

        }).sort((a, b) => {
           // Ordenação Prioritária: Pendentes primeiro, ordenados pela data de registro (mais antigo primeiro)
           // Depois, outros status ordenados pela data de verificação/conclusão (mais recente primeiro)
           const statusA = a?.status?.toLowerCase() || 'pendente';
           const statusB = b?.status?.toLowerCase() || 'pendente';
           const isAPending = statusA === 'pendente';
           const isBPending = statusB === 'pendente';

           if (isAPending && !isBPending) return -1; // Pendente A vem antes
           if (!isAPending && isBPending) return 1;  // Pendente B vem antes

           if (isAPending && isBPending) {
               // Ambos pendentes: ordenar por data de registro (mais antigo primeiro)
               const dateA = new Date(a?.registrationDate || a?.date || Infinity); // Joga inválidos pro fim
               const dateB = new Date(b?.registrationDate || b?.date || Infinity);
                if (isNaN(dateA.getTime())) return 1;
                if (isNaN(dateB.getTime())) return -1;
               return dateA - dateB;
           }

           // Nenhum é pendente: ordenar por data de verificação ou conclusão (mais recente primeiro)
           const dateA = new Date(a?.completionDate || a?.verification?.date || a?.registrationDate || 0);
           const dateB = new Date(b?.completionDate || b?.verification?.date || b?.registrationDate || 0);
            if (isNaN(dateA.getTime())) return 1;
            if (isNaN(dateB.getTime())) return -1;
           return dateB - dateA;
        });
    }


    // --- Funções Utilitárias ---

    // Sistema de notificações aprimorado
    function showNotification(message, type = 'info', duration = 5000) {
      const containerId = 'notification-container';
      let container = document.getElementById(containerId);
      if (!container) {
          container = document.createElement('div');
          container.id = containerId;
          container.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              z-index: 2000;
              display: flex;
              flex-direction: column;
              gap: 10px;
              max-width: 90%;
              width: 350px; /* Largura fixa */
          `;
          document.body.appendChild(container);
      }

      const notification = document.createElement('div');
      notification.className = `notification-popup ${type}`; // Usa a classe CSS principal
      notification.style.opacity = '0'; // Começa invisível para fade-in
      notification.style.transform = 'translateX(100%)'; // Começa fora da tela para slide-in
      notification.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out'; // Transições

      let icon = ''; let title = '';
      switch (type) {
        case 'success': icon = '✓'; title = 'Sucesso'; duration = duration < 3000 ? 3000 : duration; break; // Mínimo 3s para sucesso
        case 'error': icon = '✗'; title = 'Erro'; duration = duration < 8000 ? 8000 : duration; break; // Mínimo 8s para erro
        case 'warning': icon = '⚠️'; title = 'Aviso'; duration = duration < 6000 ? 6000 : duration; break; // Mínimo 6s para aviso
        default: icon = 'ℹ'; title = 'Informação'; type = 'info'; break;
      }
       // Certificar que a classe correta está aplicada para o estilo CSS
       notification.classList.add(type);


      notification.innerHTML = `
        <div class="notification-icon">${icon}</div>
        <div class="notification-content">
          <div class="notification-title">${title}</div>
          <div>${message}</div>
        </div>
        <span class="close-btn" style="cursor:pointer; font-size: 20px; line-height: 1;">&times;</span>`;

      // Prepend para novas notificações aparecerem no topo
      container.prepend(notification);

       // Animação de entrada (slide-in e fade-in)
      setTimeout(() => {
          notification.style.opacity = '1';
          notification.style.transform = 'translateX(0)';
       }, 10); // Pequeno delay para garantir que a transição ocorra


      const close = () => {
          notification.style.opacity = '0';
          notification.style.transform = 'translateX(100%)'; // Slide-out
           // Espera a animação de saída terminar antes de remover
           setTimeout(() => {
               // Verifica se o elemento ainda existe e pertence ao container antes de remover
               if (notification.parentNode === container) {
                   container.removeChild(notification);
               }
               // Opcional: Remover o container se estiver vazio
               // if (container.children.length === 0) {
               //     container.remove();
               // }
           }, 300); // Deve corresponder à duração da transição CSS
      };

      // Fechar ao clicar no botão 'x'
      notification.querySelector('.close-btn').onclick = close;

      // Fechar automaticamente após a duração
      setTimeout(close, duration);
    }

    // Mostrar/esconder indicador de carregamento global
    function showLoading(show, message = 'Carregando...') {
      const loaderId = 'global-loader';
      let loader = document.getElementById(loaderId);

      if (show) {
        if (!loader) {
          loader = document.createElement('div');
          loader.id = loaderId;
          // Estilos melhorados para o loader
          loader.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.8); /* Fundo branco semitransparente */
            display: flex; align-items: center;
            justify-content: center; z-index: 2100; /* Acima das notificações e do botão auth */
            color: var(--primary-color); /* Cor do texto */
            flex-direction: column;
            gap: 15px; text-align: center; padding: 20px; box-sizing: border-box;
            opacity: 0; /* Começa invisível para fade-in */
            transition: opacity 0.2s ease-in-out;
          `;
           // Spinner mais moderno (pode ser um GIF ou CSS puro)
           loader.innerHTML = `
            <div style="border: 5px solid #f3f3f3; border-top: 5px solid var(--primary-color); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite;"></div>
            <div id="global-loader-message" style="font-size: 1.1em; font-weight: 500;">${message}</div>
          `;
          document.body.appendChild(loader);

          // Add animation style se não existir
          if (!document.getElementById('spin-style')) {
            const style = document.createElement('style'); style.id = 'spin-style';
            style.textContent = `@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }`;
            document.head.appendChild(style);
          }
           // Força reflow para garantir que a transição de opacidade funcione
           void loader.offsetWidth;
           loader.style.opacity = '1'; // Fade-in
        } else {
           // Atualiza a mensagem se o loader já existir e estiver visível
           const messageElement = document.getElementById('global-loader-message');
           if (messageElement) messageElement.textContent = message;
            // Garante que esteja visível se já existia mas estava escondido
            if (loader.style.opacity === '0') {
                 loader.style.display = 'flex';
                 void loader.offsetWidth; // Reflow
                 loader.style.opacity = '1';
            } else {
                loader.style.display = 'flex'; // Garante display flex se já estava visível
            }
        }
      } else {
        if (loader) {
          loader.style.opacity = '0'; // Fade out
          // Espera a transição terminar antes de esconder com display:none
          setTimeout(() => {
              if(loader) loader.style.display = 'none';
          }, 200); // Corresponde à duração da transição de opacidade
        }
      }
    }

    // Formatar data (Brasileiro) - Melhorado
    function formatDate(dateSource, includeTime = false) {
        if (!dateSource) return '-'; // Retorna '-' se a fonte for nula ou vazia

        let date;
        try {
            // Tenta criar um objeto Date. Lida com strings (ISO, YYYY-MM-DD), números (timestamp) ou objetos Date.
            if (dateSource instanceof Date) {
                date = dateSource;
            } else if (typeof dateSource === 'string') {
                 // Se for apenas YYYY-MM-DD, adiciona T00:00:00 para interpretar no fuso local
                 if (/^\d{4}-\d{2}-\d{2}$/.test(dateSource)) {
                     date = new Date(dateSource + 'T00:00:00');
                 } else {
                      // Tenta interpretar como ISO 8601 ou outros formatos que o Date.parse entende
                     date = new Date(dateSource);
                 }
            } else if (typeof dateSource === 'number') {
                 // Assume ser um timestamp Unix (milissegundos)
                 date = new Date(dateSource);
            } else {
                 throw new Error("Tipo de entrada de data não suportado.");
            }


            // Verifica se a data resultante é válida
            if (isNaN(date.getTime())) {
                 console.warn("Data inválida após tentativa de parse:", dateSource);
                 // Tenta retornar a string original se for string, senão '-'
                 return typeof dateSource === 'string' ? dateSource : '-';
             }

            // Opções de formatação
            const options = {
                day: '2-digit', month: '2-digit', year: 'numeric',
                // É mais seguro especificar o fuso horário para evitar inconsistências
                // entre servidor e cliente, mas pode mostrar hora "errada" se o usuário espera fuso local.
                // timeZone: 'America/Sao_Paulo' // Descomente se quiser forçar um fuso
            };
            if (includeTime) {
                options.hour = '2-digit';
                options.minute = '2-digit';
                // options.second = '2-digit'; // Opcional: incluir segundos
                 options.hour12 = false; // Formato 24h
            }

            // Usa Intl.DateTimeFormat para formatação localizada
            return new Intl.DateTimeFormat('pt-BR', options).format(date);

        } catch (e) {
            console.error("Erro ao formatar data:", dateSource, e);
            // Retorna a representação string original se falhar, ou '-'
             return dateSource?.toString() || '-';
        }
    }


    // Obter classe CSS baseada no status (mantém a lógica original)
    function getStatusClass(status) {
      if (!status) return 'pending'; // Default
      const lowerStatus = status.toLowerCase();
      switch (lowerStatus) {
        case 'pendente': return 'pending';
        case 'verificado': case 'aprovado': case 'ajustes': return 'verification'; // Agrupar verificados
        case 'concluído': case 'concluido': return 'completed'; // Agrupar concluídos
        case 'reprovado': return 'danger'; // Usar classe de perigo
        default:
           console.warn("Status desconhecido recebido:", status);
           return 'pending'; // Fallback para status desconhecido
      }
    }

     // --- Funções de Validação e Auxiliares ---

    // Função Debounce para inputs de busca
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func.apply(this, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

     // Função para verificar se há dados não salvos em um formulário
     function hasUnsavedChanges(formType) {
         if (formType === 'maintenance') {
             // Verifica se campos chave foram preenchidos ou se há imagens
             if (document.getElementById('equipment-id')?.value ||
                 document.getElementById('technician-name')?.value ||
                 capturedImages.filter(img => img !== null).length > 0) { // Conta imagens válidas
                 return true;
             }
         } else if (formType === 'verification') {
             // Verifica se campos chave foram preenchidos ou se há imagens
             if (document.getElementById('verifier-name')?.value ||
                 document.querySelector('input[name="verification-result"]:checked') ||
                 verificationImages.filter(img => img !== null).length > 0) { // Conta imagens válidas
                 return true;
             }
         }
         return false;
     }

    // Função para validar campos de uma etapa do formulário
    function validateFormStep(formType, step = null) {
        let fieldsToValidate = [];
        let formId = '';
        let isValid = true;
        let firstInvalidField = null; // Para focar no primeiro erro

        if (formType === 'maintenance') {
            formId = 'maintenance-form';
            switch (step) {
                case 1: fieldsToValidate = ['equipment-id', 'equipment-type', 'technician-name', 'maintenance-date', 'location', 'maintenance-type']; break;
                case 2: fieldsToValidate = ['problem-category', 'problem-description', 'solution-description']; break;
                case 3: // Validação da etapa 3 é ter pelo menos uma imagem (feita em submitMaintenance)
                    const validImages = capturedImages.filter(img => img != null).length;
                    if (validImages === 0) {
                        document.getElementById('photo-warning').style.display = 'block';
                        showNotification('Adicione pelo menos uma foto.', 'error');
                        isValid = false;
                    } else {
                         document.getElementById('photo-warning').style.display = 'none';
                    }
                    return isValid;
                default: // Validar tudo se step for null
                    fieldsToValidate = [
                        'equipment-id', 'equipment-type', 'technician-name', 'maintenance-date', 'location', 'maintenance-type',
                        'problem-category', 'problem-description', 'solution-description'
                    ];
                    break;
            }
        } else if (formType === 'verification') {
            formId = 'verification-form';
            // Valida todos os campos obrigatórios da verificação
            fieldsToValidate = ['verifier-name', 'verification-comments']; // IDs dos inputs
             // Validar radios separadamente
             const radioGroupLabel = document.querySelector('#verification-form label[for="verification-approved"]')?.parentElement.querySelector('label:first-of-type'); // Pega o label principal do grupo
             if (!document.querySelector('input[name="verification-result"]:checked')) {
                 if(radioGroupLabel) radioGroupLabel.style.color = 'var(--danger-color)'; // Exemplo de highlight
                 isValid = false;
                 if (!firstInvalidField) firstInvalidField = document.getElementById('verification-approved'); // Define foco no grupo de radios
             } else {
                 if(radioGroupLabel) radioGroupLabel.style.color = ''; // Reset color
             }

        } else {
            return true; // Form não reconhecido
        }

        // Remover estilos de erro anteriores
        document.querySelectorAll(`#${formId} .form-control.is-invalid`).forEach(el => el.classList.remove('is-invalid'));
        document.querySelectorAll(`#${formId} input[style*="border-color: red"], #${formId} select[style*="border-color: red"], #${formId} textarea[style*="border-color: red"]`).forEach(el => el.style.borderColor = '');


        // Validar campos de input/select/textarea
        fieldsToValidate.forEach(id => {
            const input = document.getElementById(id);
            if (input && !input.value.trim()) { // Verifica se está vazio ou só tem espaços
                input.style.borderColor = 'red'; // Estilo simples
                isValid = false;
                if (!firstInvalidField) { // Guarda o primeiro campo inválido
                     firstInvalidField = input;
                 }
            } else if (input) {
                 input.style.borderColor = ''; // Reseta borda se válido
            }
        });

        if (!isValid) {
            showNotification('Por favor, preencha todos os campos obrigatórios (*).', 'error');
             // Focar no primeiro campo inválido encontrado
             if (firstInvalidField) {
                 firstInvalidField.focus();
                 // Se for um select, talvez rolar a página para ele
                 // firstInvalidField.scrollIntoView({ behavior: 'smooth', block: 'center' });
             }
        }

        return isValid;
    }

  </script>
</body>
</html>
